
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <!--<meta http-equiv="Content-Type" content="text/html;charset=utf-8" /> -->
        <title>Assignment 5</title>
        <!-- <meta http-equiv="x-ua-compatible" content="ie=edge"> -->
        <!-- <link rel="stylesheet" href="/css/default.css" /> -->
<style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
        <link rel="stylesheet" href="../../../../css/foghorn.css" />
        <link rel="icon" type="image/png" href="images/favicon-196x196.png" sizes="196x196" />
        <link rel="icon" type="image/png" href="images/favicon-96x96.png" sizes="96x96" />
        <link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="images/favicon-128.png" sizes="128x128" />    
    </head>

<body>
        <header id="title-block-header">
          <h1 class="title">Assignment 5</h1>
          <p class="subtitle">CS 4400 Programming Languages</p>
        </header>
        <main id="main">
            <p>Start early and come to us with questions.</p>
<p><strong>Due:</strong> 11pm on Thursday, October 15, 2020</p>
<p><strong>Submission:</strong></p>
<ol type="1">
<li><p>Submit the following files via <a href="https://handins.ccs.neu.edu/courses/119" class="uri">https://handins.ccs.neu.edu/courses/119</a>:</p>
<ul>
<li><code>Assignment05.hs</code></li>
<li><code>Eval.hs</code></li>
<li><code>Syntax.hs</code></li>
</ul></li>
<li><p>This assignment is meant to be worked on and submitted in pairs, but you can choose to work on your own. Note, that you need to have a team on Handins to be able to submit (a singleton team or a pair).</p></li>
<li><p>At the very top, <code>Assignment05.hs</code> should contain a preamble following this template.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">{- |</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">Module      :  Assignment05</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">Description :  Assignment 5 submission for CS 4400.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">Copyright   :  (c) &lt;your name&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">Maintainer  :  &lt;your email&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Assignment05</span> <span class="kw">where</span></span></code></pre></div>
<p>The rest of the file should contain in-comment answers to questions asked in this assignment and a <code>main</code> function running all unit tests.</p></li>
<li><p>Every top-level definition must include a purpose statement (for functions) and a type signature, followed by one or more defining equations. Every function should have meaningful tests. You can use HSpec, HUnit, or the provided <code>SimpleTests</code> module. Data definitions should have a comment with the intended interpretation and meaningful examples.</p></li>
<li><p>Double-check that you have named everything as required and that functions required by this assignment have the correct type signatures.</p></li>
<li><p>Make sure your file loads into GHCi or can be compiled by GHC without any errors. <strong>Your grade might be reduced by up to 50% if your code does not compile and run.</strong></p></li>
</ol>
<h1 id="state-of-the-union">State of the Union</h1>
<p>After the previous assignment, you should have a working implementation of <code>protoScheme</code> with the following features:</p>
<ul>
<li>let-bindings for introducing variables, and a variable reference expressions (provided to you at the beginning of the assignment and implemented using substitution)</li>
<li>arithmetic expressions, which you extended with an additional floating point value type</li>
<li>boolean expressions (including comparisons), if expressions, conditionals</li>
</ul>
<p>This assignment will add further extensions. Use the <code>Eval.hs</code> and <code>Syntax.hs</code> you submitted for the previous assignment. The pack contains a new version of <code>SimpleTests.hs</code> and an updated <code>SExpression</code> module. The updated <code>SimpleTests</code> now allows printing simple statistics: the number of tests run and how many passed / failed. See <code class="sourceCode haskell">test_toString</code> in <code>SExpression.hs</code> for an example.</p>
<h1 id="questions">Questions</h1>
<p>As before, where applicable, the questions require you to do the following:</p>
<ol type="a">
<li>extend the BNF specification with the appropriate productions,</li>
<li>extend any appropriate datatypes with new constructors as needed,</li>
<li>extend the translation functions to and from s-expressions, including <code class="sourceCode haskell">valueToSExpression</code> (if applicable),</li>
<li>implement the semantics in <code class="sourceCode haskell">eval</code> (with changes to <code class="sourceCode haskell">subst</code> as needed), and</li>
<li>write tests for any extensions to keep maximal coverage.</li>
</ol>
<hr />
<ol type="1">
<li><p>We will add our first composite value type to <code>protoScheme</code>: ordered pairs. Pairs are formed using the <code>pair</code> constructor.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> The semantics of the constructor is to evaluate the two given expressions and construct a <em>pair value</em>, containing the two values. To select elements of pairs, we will use selectors <code>left</code> and <code>right</code> for selecting the first and the second element, respectively.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<pre><code>&lt;Expr&gt; ::= ...
         | (pair &lt;Expr&gt; &lt;Expr&gt;)
         | (left &lt;Expr&gt;)
         | (right &lt;Expr&gt;)</code></pre>
<p>The selectors should satisfy the following equations:</p>
<pre><code>(left (cons a b)) = a
(right (cons a b)) = b</code></pre>
<p>Note that the s-expression datatype now contains a case for pairs, strangely called <code class="sourceCode haskell"><span class="dt">Dotted</span></code>. This is only for representing <em>pair values</em>, and is to be used as an output in <code class="sourceCode haskell">valueToSExpression</code>. This means you shouldn’t handle it in <code class="sourceCode haskell">fromSExpression</code>.</p></li>
</ol>
<ol start="2" type="1">
<li><p>Implement type predicates, which evaluate their argument and return <em>true</em> if the value is of the corresponding type and <em>false</em> if the value is of a different type.</p>
<pre><code>&lt;Expr&gt; ::= ...
         | (real? &lt;Expr&gt;)
         | (integer? &lt;Expr&gt;)
         | (number? &lt;Expr&gt;)
         | (boolean? &lt;Expr&gt;)
         | (pair? &lt;Expr&gt;)</code></pre>
<ul>
<li><code>real?</code> returns <em>true</em> only if the value is a real number</li>
<li><code>integer?</code> returns <em>true</em> only if the value is an integer</li>
<li><code>number?</code> returns <em>true</em> only if the value is a number</li>
<li><code>boolean?</code> returns <em>true</em> only if the value is a boolean</li>
<li><code>pair?</code> returns <em>true</em> only if the value is a pair</li>
</ul>
<p>Examples:</p>
<ul>
<li><code>(real? 3.14)</code> <span class="math inline">⇒</span> <code>#t</code></li>
<li><code>(integer? 31)</code> <span class="math inline">⇒</span> <code>#t</code></li>
<li><code>(number? 3.14)</code> <span class="math inline">⇒</span> <code>#t</code></li>
<li><code>(boolean? #f)</code> <span class="math inline">⇒</span> <code>#t</code></li>
<li><code>(boolean? (pair 1 2))</code> <span class="math inline">⇒</span> <code>#f</code></li>
<li><code>(pair? (pair 1 2))</code> <span class="math inline">⇒</span> <code>#t</code></li>
<li><code>(number? (left (pair 1 #t)))</code> <span class="math inline">⇒</span> <code>#t</code></li>
<li><code>(number? (right (pair 1 #t)))</code> <span class="math inline">⇒</span> <code>#f</code></li>
</ul>
<p>(<span class="math inline">⇒</span> means “evaluates to”)</p></li>
<li><p>Based on the code example from a recent lecture (which is available online), introduce a syntax category for <em>programs</em>. A program is a sequence of global definitions, followed by a single expression. A definition can be either a function definition, introduced using <code>defun</code>, or a global variable definition, introduced using <code>define</code>. Note, that functions can now have <em>one or more arguments</em>. This is reflected both in the definition and the call site in the function call expression. We recommend starting with the example from the lecture (which implements functions with one argument) then extend the syntax and semantics to handle multiple arguments. Finally, add global value definitions.</p>
<pre><code>&lt;GlobalDef&gt; ::= (defun &lt;Variable&gt; (&lt;Variable&gt; &lt;Variable&gt;*) &lt;Expr&gt;)
              | (define &lt;Variable&gt; &lt;Expr&gt;)


&lt;Program&gt; ::= &lt;GlobalDef&gt;* &lt;Expr&gt;

&lt;Expr&gt; ::= ...
         | (&lt;Variable&gt; &lt;Expr&gt; &lt;Expr&gt;*)</code></pre>
<p>A global variable or function can be used inside a function body, in a global variable definition, or in the final expression. Local variables inside expressions should take precedence: only if a variable is not bound locally, should the evaluator check the global definitions. If no global definition is found, evaluation should fail.</p>
<p>For example:</p>
<pre><code>(define x 32)

(let (x 3.14) x)</code></pre>
<p>should evaluate to <code>3.14</code>,</p>
<pre><code>(define x 32)

(let (x (* x 2)) x)</code></pre>
<p>should evaluate to <code>64</code>,</p>
<pre><code>(define x 32)

(let (y (* x 2)) x)</code></pre>
<p>should evaluate to <code>32</code>, and</p>
<pre><code>(define x 32)

(let (y (* x 2)) z)</code></pre>
<p>should fail.</p>
<p>Name the datatype of programs <code class="sourceCode haskell"><span class="dt">Program</span></code>.</p>
<p>Implement the function <code class="sourceCode haskell">programFromSExpression</code> which takes an s-expression and returns a program.</p>
<p>Implement the function <code class="sourceCode haskell">evalProgram</code> which processes global definitions and evaluates the final expression. Update the <code class="sourceCode haskell">runProgram</code> function in <code>Eval.hs</code> so that it takes <code class="sourceCode haskell"><span class="dt">Program</span></code> instead of <code class="sourceCode haskell"><span class="dt">Expr</span></code>.</p></li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This is a departure from standard Scheme, where pairs are formed using <code>cons</code>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>In Scheme, the selectors are <code>car</code> and <code>cdr</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
        </main>
  <!--<div id="statcounter_image" style="display:inline;"><a
       title="free hit counter"
       href="http://statcounter.com/free-hit-counter/"
       class="statcounter"><img
       src="http://c.statcounter.com/10419673/0/67e2ca33/1/"
       alt="free hit counter" style="border:none;" /></a></div>-->
</body>

