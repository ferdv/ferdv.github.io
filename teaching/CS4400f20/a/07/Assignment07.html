
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <!--<meta http-equiv="Content-Type" content="text/html;charset=utf-8" /> -->
        <title>Assignment 7</title>
        <!-- <meta http-equiv="x-ua-compatible" content="ie=edge"> -->
        <!-- <link rel="stylesheet" href="/css/default.css" /> -->
<style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
        <link rel="stylesheet" href="../../../../css/foghorn.css" />
        <link rel="icon" type="image/png" href="images/favicon-196x196.png" sizes="196x196" />
        <link rel="icon" type="image/png" href="images/favicon-96x96.png" sizes="96x96" />
        <link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="images/favicon-128.png" sizes="128x128" />    
    </head>

<body>
        <header id="title-block-header">
          <h1 class="title">Assignment 7</h1>
          <p class="subtitle">CS 4400 Programming Languages</p>
        </header>
        <main id="main">
            <p>Start early and come to us with questions.</p>
<p><strong>Due:</strong> 11pm on Wednesday, November 4, 2020</p>
<p><strong>Submission:</strong></p>
<ol type="1">
<li><p>Submit the following files via <a href="https://handins.ccs.neu.edu/courses/119" class="uri">https://handins.ccs.neu.edu/courses/119</a>:</p>
<ul>
<li><code>Assignment07.hs</code></li>
<li><code>Church.hs</code></li>
<li><code>Compiler.hs</code></li>
<li><code>Syntax.hs</code></li>
<li><code>Eval.hs</code></li>
</ul></li>
<li><p>This assignment is meant to be worked on and submitted in pairs, but you can choose to work on your own. Note, that you need to have a team on Handins to be able to submit (a singleton team or a pair).</p></li>
<li><p>At the very top, the file should contain a preamble following this template.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">{- |</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">Module      :  Assignment07</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">Description :  Assignment 7 submission for CS 4400.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">Copyright   :  (c) &lt;your name&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">Maintainer  :  &lt;your email&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Assignment07</span> <span class="kw">where</span></span></code></pre></div>
<p>The file should contain a <code>main</code> function which runs all tests in the submission, as well as additional definitions required by this assignment.</p></li>
<li><p>Every top-level definition must include a purpose statement (for functions) and a type signature, followed by one or more defining equations.</p></li>
<li><p>Double-check that you have named everything as required and that functions required by this assignment have the correct type signatures.</p></li>
<li><p>Make sure your file loads into GHCi or can be compiled by GHC without any errors. <strong>Your grade might be reduced by up to 50% if your code does not compile and run.</strong></p></li>
</ol>
<p><strong>Purpose:</strong> To experiment with translating a higher-level language to a minimal core calculus and to practice working with Church encodings.</p>
<h1 id="overview">Overview</h1>
<p>In this assignment, we will perform an experiment: we will take a subset of protoScheme and compile it into pure lambda calculus. This entails: translating values (booleans and numbers, restricted to naturals), translating arithmetic and boolean operations, an if conditional, and finally, translating function calls, and global value and function definitions.</p>
<p>We will limit ourselves to a subset of protoScheme outlined below. However, do not modify your <code>Syntax</code> or <code>Eval</code> module by removing things. This experiment will exist in parallel to your main implementation.</p>
<ol type="a">
<li><p>values: only integers <span class="math inline">≥</span> 0 (i.e., natural numbers) and booleans</p></li>
<li><p>expressions:</p></li>
</ol>
<pre><code>&lt;Expr&gt; ::= &lt;Variable&gt;
         | (+ &lt;Expr&gt; &lt;Expr&gt;)
         | (- &lt;Expr&gt; &lt;Expr&gt;)
         | (* &lt;Expr&gt; &lt;Expr&gt;)
         | (let (&lt;Variable&gt; &lt;Expr&gt;) &lt;Expr&gt;)
         | (if &lt;Expr&gt; &lt;Expr&gt; &lt;Expr&gt;)
         | (and &lt;Expr&gt; &lt;Expr&gt;)
         | (or &lt;Expr&gt; &lt;Expr&gt;)
         | (not &lt;Expr&gt;)
         | (&lt; &lt;Expr&gt; &lt;Expr&gt;)
         | (&gt; &lt;Expr&gt; &lt;Expr&gt;)
         | (= &lt;Expr&gt; &lt;Expr&gt;)
         | (&lt;Variable&gt; &lt;Expr&gt; &lt;Expr&gt;*)</code></pre>
<ol start="3" type="a">
<li>programs: global definitions with an expression</li>
</ol>
<p>The goal is to have enough in place to be able to compile a factorial program and run it by applying normal reduction to it.</p>
<p>You are expected to refer to the following notes provided online:</p>
<ul>
<li>“Introduction to Lambda Calculus”, <a href="https://vesely.io/teaching/CS4400f20/l/10/10.pdf" class="uri">https://vesely.io/teaching/CS4400f20/l/10/10.pdf</a></li>
<li>“Programming in Pure Lambda Calculus”, <a href="https://vesely.io/teaching/CS4400f20/l/13/13.pdf" class="uri">https://vesely.io/teaching/CS4400f20/l/13/13.pdf</a></li>
</ul>
<p>Do ask questions. This assignment doesn’t require you to write a huge amount of code, but some of the concepts might feel a little difficult at first. The deadline for this assignment allows you to</p>
<h1 id="pack">Pack</h1>
<p>The assignment pack contains the following:</p>
<dl>
<dt><code>Lambda.hs</code></dt>
<dd><p>Syntax of pure lambda calculus.</p>
</dd>
<dt><code>Reduce.hs</code></dt>
<dd><p>Normal order reduction for pure lambda calculus. Contains the functions <code>normalize</code> and <code>normalizeWithCount</code>, which you will use in this assignment.</p>
</dd>
<dt><code>Church.hs</code></dt>
<dd><p>Church encodings of values and operations. <strong>You will need to complete this file.</strong></p>
</dd>
<dt><code>Compiler.hs</code></dt>
<dd><p>Compilation from protoScheme expressions/programs into pure lambda calculus. <strong>You will need to modify this file.</strong></p>
</dd>
<dt><code>SimpleTests{Color}.hs</code></dt>
<dd><p>No changes.</p>
</dd>
<dt><code>SExpression.hs</code></dt>
<dd><p>No changes.</p>
</dd>
<dt><code>Parser.hs</code></dt>
<dd><p>No changes.</p>
</dd>
</dl>
<h1 id="questions">Questions</h1>
<ol type="1">
<li><p>[In <code>Church.hs</code>] Complete the implementation of <code class="sourceCode haskell">toChurchBool</code>, a function converting Haskell booleans to Church-encoded booleans, and its reverse, <code class="sourceCode haskell">fromChurchBool</code>, a function for converting a Church boolean (in normal form) into its Haskell counterpart:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">toChurchBool ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Lambda</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="ot">fromChurchBool ::</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span></span></code></pre></div>
<p>The function <code>fromChurchBool</code> should assume that the <code>Lambda</code> term is normalized, that is, the term will be in the canonical form presented in the lecture (or the notes) for true or false. However, due to alpha-equivalence, do you should not assume anything about the names of bound variables. For any <code class="sourceCode haskell"><span class="dt">Lambda</span></code> term that is not a canonical Church boolean, the function should return <code>Nothing</code>.</p>
<p>The two conversion functions should satisfy the following property, for all <code>b</code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>fromChurchBool (toChurchBool b) <span class="op">==</span> <span class="dt">Just</span> b</span></code></pre></div>
<p>Write tests as <code class="sourceCode haskell">test_bools</code></p></li>
<li><p>[In <code>Church.hs</code>] Implement a function converting an <code class="sourceCode haskell"><span class="dt">Integer</span></code> <span class="math inline"><em>x</em></span>, where <span class="math inline"><em>x</em> ≥ 0</span> to a Church numeral and its reverse, a conversion from a Church numeral to an integer.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">toNumeral ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Lambda</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">fromNumeral ::</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Integer</span></span></code></pre></div>
<p>The function <code class="sourceCode haskell">fromNumeral</code> should assume that the <code class="sourceCode haskell"><span class="dt">Lambda</span></code> term is normalized, that is, the Church numeral will be in the canonical form presented in the lecture (or the notes). However, do not assume anything about the names of bound variables. For any <code>Lambda</code> term that is not a canonical Church numeral, the function should return <code>Nothing</code>.</p>
<p>These operations should satisfy the following, for all <code>i</code> <span class="math inline"> ≥ 0</span>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>fromNumeral (toNumeral i) <span class="op">==</span> <span class="dt">Just</span> i</span></code></pre></div>
<p>Write tests as <code class="sourceCode haskell">test_numerals</code></p></li>
<li><p>[In <code>Church.hs</code>] Complete the tests and definitions of Church-encoded value operations. Writing <em>at least</em> one test for each, in the style of the example provided for <code class="sourceCode haskell">cplus</code>. Write the tests in the respective <code class="sourceCode haskell">test_</code> definition, replacing <code class="sourceCode haskell"><span class="fu">undefined</span></code>.</p></li>
<li><p>[In <code>Compiler.hs</code>] Complete the <code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">L.Lambda</span></code> function which will translate a protoScheme expression into pure lambda calculus. You only need to cover the above constructs. For all other cases, return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p></li>
<li><p>[In <code>Compiler.hs</code>] Complete the <code class="sourceCode haskell">compileProgram</code> function, which should take a protoScheme program with global definitions and translate it into a pure lambda expression. Global definitions can be translated the same way let expressions are translated. Function definitions should be recursive, using the fixed point combinator, which we will discuss in class this week.</p></li>
<li><p>[In <code>Compile.hs</code>] Complete the function <code class="sourceCode haskell"><span class="ot">factorialProgram ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code>, which generates the source code for a protoScheme factorial program, calculating the factorial of the given number. Write a test which generates a program for a low but interesting number (greater than 2), parses it into a protoScheme expression, compiles it into pure lambda calculus, runs it using <code class="sourceCode haskell">normalize</code>, (provided in <code>Reduce.hs</code>) and converts the result back into an integer. Note: this will be <em>slow</em>. Like, <em>very</em> slow. Make sure you test your compiler with simpler functions first.</p></li>
<li><p>Run the program with 4 as the parameter using <code>normalizeWithCount</code>. This function will return the normalized lambda term (which should represent the factorial of 4) paired up with the total number of reduction steps it took to normalize the lambda expression. In <code>Assignment07.hs</code>, write the number of steps taken to reduce factorial of 4 as a global variable <code>fact4StepsBefore</code>. Modify your <code>compileProgram</code> function so that it normalizes function bodies (using <code>normalize</code>). This is a simple optimization step, optimizing the function body before it runs on actual arguments. Rerun the factorial calculation with <code>normalizeWithCount</code> and write the number of steps as <code>fact4StepsAfter</code> in <code>Assignment07.hs</code>. If you have time, try the above experiment with the factorial of 5 and add your results as <code>fact5StepsBefore</code> and <code>fact5StepsAfter</code>.</p></li>
</ol>
        </main>
  <!--<div id="statcounter_image" style="display:inline;"><a
       title="free hit counter"
       href="http://statcounter.com/free-hit-counter/"
       class="statcounter"><img
       src="http://c.statcounter.com/10419673/0/67e2ca33/1/"
       alt="free hit counter" style="border:none;" /></a></div>-->
</body>

