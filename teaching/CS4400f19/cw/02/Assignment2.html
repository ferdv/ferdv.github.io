
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <!--<meta http-equiv="Content-Type" content="text/html;charset=utf-8" /> -->
        <title>Assignment 2</title>
        <!-- <meta http-equiv="x-ua-compatible" content="ie=edge"> -->
        <!-- <link rel="stylesheet" href="/css/default.css" /> -->
<style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
        <link rel="stylesheet" href="../../../../css/foghorn.css" />
        <link rel="icon" type="image/png" href="images/favicon-196x196.png" sizes="196x196" />
        <link rel="icon" type="image/png" href="images/favicon-96x96.png" sizes="96x96" />
        <link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="images/favicon-128.png" sizes="128x128" />    
    </head>

<body>
        <header id="title-block-header">
          <h1 class="title">Assignment 2</h1>
          <p class="subtitle">CS 4400 / CS 5400 Programming Languages</p>
        </header>
        <main id="main">
            <h1 id="general">General</h1>
<p><strong>Due:</strong> Thursday, October 17, 11:59pm.</p>
<p><strong>Instructions:</strong></p>
<ol type="1">
<li><p>Download the assignment pack from <a href="https://vesely.io/teaching/CS4400f19/m/cw/02/Assignment2.zip" class="uri">https://vesely.io/teaching/CS4400f19/m/cw/02/Assignment2.zip</a>.</p></li>
<li><p>You can choose to complete this assignment as a pair. If you work as a pair, submit as a pair. Completing an assignment with a partner but submitting individually is considered cheating.</p></li>
<li><p>Submit via the Khoury Handin server: <a href="https://handins.ccs.neu.edu/" class="uri">https://handins.ccs.neu.edu/</a> (the course is not yet set up on the server, so please wait before checking)</p></li>
<li><p>Complete the information in <code>Assignment2.hs</code> and submit modified Haskell files: <code>Env.hs</code>, <code>ABL.hs</code>, <code>StrictEnvABL.hs</code>, and <code>Assignment2.hs</code>.</p></li>
<li><p>You are free to add top-level definitions, but add them to the bottom of each file, below the separator line.</p></li>
<li><p>Each top-level function must include a type signature, followed by one or more defining equations.</p></li>
<li><p>Make sure your file loads into GHCi or can be compiled by GHC without any errors.</p></li>
<li><p>A complete solution will contain no <code>undefined</code>s and will implement all cases from <code>ABLExpr</code>.</p></li>
<li><p>Use the provided <code>SimpleTests</code> module to write your own tests in the <code>tests</code> function. Follow the examples provided in <code>Env</code>, <code>ABL</code>, and <code>StrictEnvABL</code>.</p></li>
</ol>
<p><strong>Grade:</strong> To calculate your grade, we will take the following into account:</p>
<ol type="a">
<li>Quality of submission: Does your code compile without errors? Did you follow the above steps?</li>
<li>Correctness: How well does it implement the specification?</li>
<li>QA: How well did you test your code?</li>
<li>Is your code readable?</li>
</ol>
<h1 id="partial-functions-in-haskel">Partial Functions in Haskel</h1>
<p>This assignment is mainly made up of partial functions. A partial function (that is, a function which is not defined for all possible inputs) can be represented using the option type <code class="sourceCode haskell"><span class="dt">Maybe</span></code>. The type is predefined by Haskell as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> </span>
<span id="cb1-2"><a href="#cb1-2"></a>             <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>For example, the integer division operation in Haskell, <code class="sourceCode haskell"><span class="fu">div</span></code> throws an exception if the second argument is <code>0</code>. We can convert it into a partial function as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">maybeDiv ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Integer</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>maybeDiv _ <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>maybeDiv n d <span class="ot">=</span> <span class="dt">Just</span> (n <span class="ot">`div`</span> d)  <span class="co">-- n `div` d is a fancy way of writing div n d </span></span></code></pre></div>
<p>Now <code class="sourceCode haskell">maybeDiv <span class="dv">5</span> <span class="dv">0</span></code> will return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, whereas <code class="sourceCode haskell">maybeDiv <span class="dv">5</span> <span class="dv">2</span></code> will return <code class="sourceCode haskell"><span class="dt">Just</span> <span class="dv">2</span></code>.</p>
<p>To use (and compose) partial operations, we can use the case construct:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">divideThenAdd2 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Integer</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>divideThenAdd2 x y <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">case</span> maybeDiv x y <span class="kw">of</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>       <span class="dt">Just</span> z <span class="ot">-&gt;</span> <span class="dt">Just</span> (r <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<h1 id="environments-as-association-lists">Environments as Association Lists</h1>
<h4 id="exercise-1">Exercise 1</h4>
<p>Complete <code>Env.hs</code> by implementing environments as <em>association lists</em>. An association list is a list of pairs – the first member is a variable, the second is the value. For example, <code class="sourceCode haskell">[(<span class="st">&quot;x&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;y&quot;</span>, <span class="dv">2</span>)]</code> binds <code>"x"</code> to <code>1</code> and <code>"y"</code> to <code>2</code>. The most recent binding overrides any previous ones, that is, the environment <code class="sourceCode haskell">[(<span class="st">&quot;x&quot;</span>, <span class="dv">100</span>), (<span class="st">&quot;x&quot;</span>, <span class="dv">1</span>)]</code> binds <code>"x"</code> to the value <code>100</code>, NOT <code>1</code>. Provide implementation for:</p>
<ul>
<li><code>empty</code> – the empty environment</li>
<li><code>add</code> – add a binding for the given variable. That is <code>add "x" 10 env</code> binds <code>"x"</code> to the value <code>10</code> in the environment <code>env</code></li>
<li><code>get</code> – find the binding for the given variable. This is a partial function: <code class="sourceCode haskell">get <span class="st">&quot;x&quot;</span> [(<span class="st">&quot;x&quot;</span>, <span class="dv">10</span>)]</code> should return <code class="sourceCode haskell"><span class="dt">Just</span> <span class="dv">10</span></code>, while <code class="sourceCode haskell">get <span class="st">&quot;y&quot;</span> [(<span class="st">&quot;x&quot;</span>, <span class="dv">10</span>)]</code> should return <code>Nothing</code></li>
</ul>
<p>The following laws, expressed in Haskell, should hold for the above functions. In other words, these Haskell expressions should always return <code>True</code> for any <code>x</code>, <code>y</code>, <code>v</code>, and <code>env</code>. Assume <code class="sourceCode haskell">x <span class="op">/=</span> y</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>get x empty <span class="op">==</span> <span class="dt">Nothing</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>get x (add x v env) <span class="op">==</span> <span class="dt">Just</span> v</span>
<span id="cb4-3"><a href="#cb4-3"></a>get x (add y v env) <span class="op">==</span> get x env</span></code></pre></div>
<h1 id="the-abl-language">The ABL language</h1>
<h2 id="syntax">Syntax</h2>
<p>The ABL language has the following syntax:</p>
<pre><code>&lt;ABLValue&gt; ::= &lt;Integer&gt;                               // tag: Num
             | &lt;Bool&gt;                                  // tag: Bool

&lt;ABLExpr&gt; ::= &lt;Variable&gt;                               // tag: Var
            | &lt;ABLValue&gt;                               // tag: Val
            | (+ &lt;ABLExpr&gt; &lt;ABLExpr&gt;)                  // tag: Add
            | (- &lt;ABLExpr&gt; &lt;ABLExpr&gt;)                  // tag: Sub
            | (* &lt;ABLExpr&gt; &lt;ABLExpr&gt;)                  // tag: Mul
            | (/ &lt;ABLExpr&gt; &lt;ABLExpr&gt;)                  // tag: Div
            | (= &lt;ABLExpr&gt; &lt;ABLExpr&gt;)                  // tag: Eq
            | (&amp;&amp; &lt;ABLExpr&gt; &lt;ABLExpr&gt;)                 // tag: And
            | (|| &lt;ABLExpr&gt; &lt;ABLExpr&gt;)                 // tag: Or
            | (not &lt;ABLExpr&gt;)                          // tag: Not
            | (let1 (&lt;Variable&gt; &lt;ABLExpr&gt;) &lt;ABLExpr&gt;)  // tag: Let1  
            | (if-else &lt;ABLExpr&gt; &lt;ABLExpr&gt; &lt;ABLExpr&gt;)  // tag: If</code></pre>
<hr />
<h4 id="exercise-2">Exercise 2</h4>
<p>The file <code>ABL.hs</code> contains the initial definitions for the <code>ABLValue</code> and <code>ABLExpr</code> data types. Following the examples in <code>ABL.hs</code>, add the remaining constructor definitions for <code>ABLExpr</code>, using tags from the BNF definition above as constructor names.</p>
<h4 id="exercise-3">Exercise 3</h4>
<p>In <code>ABL.hs</code>, complete the definition for <code>showABL</code>, which pretty-prints ABL into a string as s-expressions, based on the above BNF rules. Add new cases for each new construct you add to the language in exercises 7 and 8.</p>
<hr />
<h2 id="semantics">Semantics</h2>
<p>Behavior of ABL’s constructs is described below. <em>Current environment</em> for a construct refers to the set of bindings visible when starting the evaluation of the construct. In other words, it is the unmodified environment passed to the evaluator as an argument together with the expression.</p>
<h3 id="variables">Variables</h3>
<pre><code>&lt;Variable&gt; </code></pre>
<p>A variable reference should evaluate to the value bound to it in the current environment. If the variable is not in scope, the evaluation should result in <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p>
<h3 id="values">Values</h3>
<pre><code>&lt;ABLValue&gt;</code></pre>
<p>A value should trivially evaluate to itself.</p>
<h3 id="arithmetic-operations">Arithmetic Operations</h3>
<pre class="bnf"><code>(+ &lt;ABLExpr&gt; &lt;ABLExpr&gt;)
(- &lt;ABLExpr&gt; &lt;ABLExpr&gt;)
(* &lt;ABLExpr&gt; &lt;ABLExpr&gt;)
(/ &lt;ABLExpr&gt; &lt;ABLExpr&gt;)</code></pre>
<p>The operands should be evaluated left to right. Then the corresponding operation should be applied to the values. If any of the operands do not evaluate to integer values, the evaluator should return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>. If the right operand of division (<code>/</code>) evaluates to <code>0</code>, the evaluator should return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p>
<h3 id="equality">Equality</h3>
<pre><code>(= &lt;ABLExpr&gt; &lt;ABLExpr&gt;)</code></pre>
<p>Operands should be evaluated left to right. Then the values should be compared for equality. If the values are of a different type, the evaluator is to return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p>
<h3 id="boolean-operations">Boolean Operations</h3>
<pre><code>(and &lt;ABLExpr&gt; &lt;ABLExpr&gt;)
(or &lt;ABLExpr&gt; &lt;ABLExpr&gt;)
(not &lt;ABLExpr&gt;)</code></pre>
<p>The operands should be evaluated left to right. Then the corresponding operation should be applied. If any of the operands do not evaluate to boolean values, the evaluator shall return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p>
<h3 id="single-let-bindings">Single Let Bindings</h3>
<pre><code>(let1 (&lt;Variable&gt; &lt;ABLExpr&gt;) &lt;ABLExpr&gt;)</code></pre>
<p>An expression <code>(let1 (x e1) e2)</code> should be evaluated as follows. First evaluate the left expression <code>e1</code> with the current set of bindings. Then the right expression <code>e2</code> should be evaluated with the same set of bindings, except <code>x</code> is bound to the value corresponding to <code>e1</code>. If <code>e1</code> fails to evaluate, then the evaluation of the whole expression result should return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p>
<h3 id="conditional">Conditional</h3>
<pre><code>(if-else &lt;ABLExpr&gt; &lt;ABLExpr&gt; &lt;ABLExpr&gt;)</code></pre>
<p>A conditional expression <code>(if-else e1 e2 e3)</code> should be evaluate by first evaluating <code>e1</code> to a boolean value. If the result is <em>true</em>, then the value resulting from evaluating <code>e2</code> shall be returned. If the result is <em>false</em>, then the result of evaluating <code>e3</code> should be returned. If <code>e1</code> does not evaluate to a boolean, evaluation should return <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p>
<hr />
<p>Complete the definitions in <code>StrictEnvABL.hs</code>.</p>
<h4 id="exercise-4">Exercise 4</h4>
<p>Checking the type of values before applying each operation is repetitive and tiresome. It is therefore useful to abstract this process into two higher-order functions: <code>applyIntegerBinOp</code> for applying integer operations, and <code>applyBoolBinOp</code> for applying boolean operation. Then, for example, to perform addition on two <code>ABLValue</code>s, we can simply call <code class="sourceCode haskell">applyBinIntegerOp (<span class="op">+</span>) v1 v2</code>. We have implemented the former for you. Your task is to complete <code>applyBoolBinOp</code>, following the example in the file.</p>
<h4 id="exercise-5">Exercise 5</h4>
<p>Complete the evaluator for ABL, <code>evalABL</code>, implementing the behavior of ABL constructs as described above. Use <code>applyIntegerBinOp</code> and <code>applyBoolBinOp</code> where appropriate. Note: For integer division, use the function <code>div</code>.</p>
<h4 id="exercise-6">Exercise 6</h4>
<p>Complete the function <code>scopeCheck</code> which checks if all variables in an ABL expression are defined before they are used. Trivial examples: for <code>(let (y 10) (+ y y))</code> the function should return <code class="sourceCode haskell"><span class="dt">True</span></code>, while for <code>(let (y 10) (+ y x))</code> it should return <code class="sourceCode haskell"><span class="dt">False</span></code>.</p>
<h3 id="extensions-to-abl">Extensions to ABL</h3>
<p>For each extension, update the syntax in <code>ABL.hs</code>, as well as the relevant functions in <code>ABL.hs</code> and <code>StringEnvABL.hs</code>.</p>
<h4 id="exercise-7">Exercise 7</h4>
<p>Implement a new construct which “forgets” the current environment and evaluates its argument as if it was a top-level expression (that is, in an empty environment).</p>
<p>The syntax is as follows:</p>
<pre><code>...
    | (fresh-env &lt;ABLExpr&gt;)      // tag: Fresh</code></pre>
<p>Extend <code>scopeCheck</code> to handle this new construct.</p>
<h4 id="exercise-8">Exercise 8</h4>
<p>Implement an improved, generalized let-binding construct, named <code>let*</code>:</p>
<pre><code>...
    | (let* ((&lt;Variable&gt; &lt;ABLExpr&gt;) ...) &lt;ABLExpr&gt;)  // tag: LetStar</code></pre>
<p>where <code>(&lt;Variable&gt; &lt;ABLExpr&gt;) ...</code> is a, possibly empty, list of bindings. The corresponding Haskell constructor has the following shape:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>  <span class="op">|</span> <span class="dt">LetStar</span> [(<span class="dt">Variable</span>, <span class="dt">ABLExpr</span>)] <span class="dt">ABLExpr</span></span></code></pre></div>
<p>The evaluation of <code>(let* ((x1 e1) (x2 e2) ... (xn en)) e)</code> is equivalent to <code>(let1 (x1 e1) (let1 (x2 e2) ... (let1 (xn en) e)))</code>. If the list of bindings is empty, as in <code>(let1 () e)</code>, then the evaluation is equivalent to <code>e</code>. For evaluating <code>let*</code> implement the auxiliary function <code>unfoldLetStar</code> which, given a list of bindings, outputs the corresponding expression formed of nested <code>let1</code> expressions. For example:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>unfoldLetStar [] e <span class="op">==</span> e</span>
<span id="cb16-2"><a href="#cb16-2"></a>unfoldLetStar [(x1, e1), (x2, e2)] e <span class="op">==</span> <span class="dt">Let1</span> x1 e1 (<span class="dt">Let1</span> x2 e2 e)</span></code></pre></div>
<p>Implement the evaluation of <code>let*</code> with the help of <code>unfoldLetStar</code>.</p>
<p>Extend <code>scopeCheck</code> to handle this construct.</p>
        </main>
  <!--<div id="statcounter_image" style="display:inline;"><a
       title="free hit counter"
       href="http://statcounter.com/free-hit-counter/"
       class="statcounter"><img
       src="http://c.statcounter.com/10419673/0/67e2ca33/1/"
       alt="free hit counter" style="border:none;" /></a></div>-->
</body>

