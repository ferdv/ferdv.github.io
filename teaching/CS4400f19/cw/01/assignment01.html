
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <!--<meta http-equiv="Content-Type" content="text/html;charset=utf-8" /> -->
        <title>Assignment 1</title>
        <!-- <meta http-equiv="x-ua-compatible" content="ie=edge"> -->
        <!-- <link rel="stylesheet" href="/css/default.css" /> -->
<style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
        <link rel="stylesheet" href="../../../../css/foghorn.css" />
        <link rel="icon" type="image/png" href="images/favicon-196x196.png" sizes="196x196" />
        <link rel="icon" type="image/png" href="images/favicon-96x96.png" sizes="96x96" />
        <link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="images/favicon-128.png" sizes="128x128" />    
    </head>

<body>
        <header id="title-block-header">
          <h1 class="title">Assignment 1</h1>
          <p class="subtitle">CS 4400 / CS 5400 Programming Languages</p>
        </header>
        <main id="main">
            <p><strong>Due:</strong> Friday, September 27, by midnight.</p>
<p><strong>Submission:</strong></p>
<ol type="1">
<li><p>Submit one file named <code>Assignment1.hs</code> via <a href="https://blackboard.northeastern.edu/">Blackboard</a>.</p></li>
<li><p>At the very top, the file should contain a preamble following this template.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">{- |</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">Module      :  Assignment1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">Description :  Assignment 1 submission for &lt;CS 4400 / CS 5400 (choose one)&gt;.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">Copyright   :  (c) &lt;your name&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">Maintainer  :  &lt;your email&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Assignment1</span> <span class="kw">where</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">-- your code goes here</span></span></code></pre></div>
<p>The rest of the file will contain your solutions to the exercises below.</p></li>
<li><p>Each top-level function must include a type signature, followed by one or more defining equations.</p></li>
<li><p>Make sure your file loads into GHCi or can be compiled by GHC without any errors.</p></li>
</ol>
<p><strong>Purpose:</strong> The purpose of this assignment is to get a bit of practice with Haskell, especially with processing lists and trees. Most of the concepts involved in the exercises here should be familiar to you from prerequisite courses or other parts of the curriculum. However, the Haskell specifics might be new, in particular working with types, polymorphism, typeclasses, and some of the syntax. If something is not clear, you are encouraged:</p>
<ol type="a">
<li>to look at online resources – see the course page for online material; and</li>
<li>to ask questions after class, during office hours, or on Piazza.</li>
</ol>
<p>We also recommend familiarizing yourself with <a href="https://hoogle.haskell.org">Hoogle</a> – a very handy search engine for Haskell’s libraries. It allows searching by name or by type.</p>
<p><strong>Grade:</strong> To calculate your grade, we will take the following into account:</p>
<ol type="a">
<li>Does your code compile without errors?</li>
<li>Does it follow the above rules?</li>
<li>Are functions and constants named as specified? Do they have the correct types?</li>
<li>Does your code behave as specified? This will be determined by unit testing.</li>
<li>How readable is your code?</li>
</ol>
<p>Readability will initially play a small role, but will become more important with each further assignment.</p>
<h1 id="exercises">Exercises</h1>
<h2 id="recursive-functions">Recursive Functions</h2>
<p><strong>Task 1:</strong> Give a definition of <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a> as a recursive function named <code>fibonacci</code> with the following type signature:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>fibonacci <span class="op">:</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span></code></pre></div>
<p>Tip: Use the factorial example from lecture 1 (in <code>Lec01.hs</code>) as guidance, but pay attention to how many base cases you need for <code>fibonacci</code>.</p>
<h2 id="lists-and-polymorphism">Lists and Polymorphism</h2>
<p>Haskell lists are defined using the empty list constructor <code class="sourceCode haskell">[]</code> and the infix cons constructor <code class="sourceCode haskell">_ <span class="op">:</span> _</code>. Moreover, list values can be constructed by listing values between <code class="sourceCode haskell">[</code> and <code class="sourceCode haskell">]</code>, separated by a comma <code class="sourceCode haskell">,</code>. The following are all list values:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>[]              <span class="co">-- empty list</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]       <span class="co">-- list containing the numbers 1, 2 and 3</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="dv">1</span> <span class="op">:</span> [<span class="dv">2</span>, <span class="dv">3</span>]      <span class="co">-- the same list as above</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> <span class="dv">3</span> <span class="op">:</span> []  <span class="co">-- the same as above</span></span></code></pre></div>
<p>Functions over lists can pattern-match on these two constructors. For example, here is how we define the length of a list:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="fu">length</span> [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="fu">length</span> (x <span class="op">:</span> xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">length</span> xs</span></code></pre></div>
<p>This is a <em>polymorphic function</em>: it works on lists with elements of any type, as it does not depend on any specific operations on the element type. This is captured in its type by using the type variable <code class="sourceCode haskell">a</code> instead of a particular type.</p>
<hr />
<h4 id="note-on-function-types-in-haskell">Note on function types in Haskell</h4>
<p>In Haskell, function types have the general form:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">f ::</span> <span class="dt">ArgumentType1</span> <span class="ot">-&gt;</span> <span class="dt">ArgumentType2</span> <span class="ot">-&gt;</span> <span class="op">...</span> <span class="ot">-&gt;</span> <span class="dt">ArgumentTypeN</span> <span class="ot">-&gt;</span> <span class="dt">ReturnType</span></span></code></pre></div>
<p>The last arrow separates argument types from the return type. This means that a unary function which takes an integer and returns a boolean has the type <code class="sourceCode haskell"><span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code>; a function which takes an integer and a string, returning a boolean <code class="sourceCode haskell"><span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code>; a function which takes three intgers and returns a boolean <code class="sourceCode haskell"><span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code>; and so on. We will talk about the reasons for this notation later on, but, for now, think of the type signature</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">g ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>as saying</p>
<blockquote>
<p>The function <code>g</code> takes an <code>Integer</code> <em>then</em> it takes another <code>Integer</code> <em>then</em> it takes another <code>Integer</code> and, finally, returns a <code>Bool</code>.</p>
</blockquote>
<hr />
<p><strong>Task 2:</strong> Checking if a list contains the given value.</p>
<p>Give a recursive definition for the function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">isIntegerElem ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>(That is, a function <code>isIntegerElem</code> which takes an <code class="sourceCode haskell"><span class="dt">Integer</span></code> and a list of <code>Integer</code>s and returns a <code>Bool</code>.)</p>
<p>This function should go through the list and return <code class="sourceCode haskell"><span class="dt">True</span></code> if it finds the given element or <code class="sourceCode haskell"><span class="dt">False</span></code> if the list contains no such element. Here are some test cases:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>isIntegerElem <span class="dv">0</span> [] <span class="op">==</span> <span class="dt">False</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>isIntegerElem <span class="dv">0</span> [<span class="dv">0</span>] <span class="op">==</span> <span class="dt">True</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>isIntegerElem <span class="dv">1</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>] <span class="op">==</span> <span class="dt">True</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>isIntegerElem <span class="dv">1</span> [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">0</span>] <span class="op">==</span> <span class="dt">False</span></span></code></pre></div>
<p>If you have written your function well, you might notice that it should work for any type that supports equality, not just integers. This means that its type is not as general as possible and we might want to <em>generalize</em> it. Haskell provides <a href="https://en.wikipedia.org/wiki/Type_class"><em>typeclasses</em></a> as a mechanism to support <em>ad hoc polymorphism</em>. For example, the <code>Eq</code> typeclass requires the <code class="sourceCode haskell"><span class="op">==</span></code> (“equal to”) and <code class="sourceCode haskell"><span class="op">/=</span></code> (“not equal to”) operations. To use equality in our function, we need to add a <em>typeclass constraint</em> to the type of the function. For example, if I wish to write a function <code class="sourceCode haskell"><span class="ot">foo ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></code> and I want it to work for any type <code>a</code> with equality, I say so in the type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">foo ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>foo x <span class="ot">=</span> <span class="op">...</span> (x <span class="op">==</span> <span class="op">...</span> <span class="co">-- foo can use equality on values of type a</span></span></code></pre></div>
<p><strong>Task 3</strong>: Generalizing the type of <code>isIntegerElem</code>.</p>
<p>Adapt <code>isIntegerElem</code> into a function <code>isElem</code> that works for any type with equality (not just integers) by adding a typeclass constraint to its type. Give the function’s type signature and adapt the definition you gave for <code>isIntegerElem</code> as appropriate.</p>
<p>Example test cases:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>isElem <span class="st">&quot;x&quot;</span> [<span class="st">&quot;x&quot;</span>] <span class="op">==</span> <span class="dt">True</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>isElem <span class="st">&quot;x&quot;</span> [<span class="st">&quot;xyz&quot;</span>] <span class="op">==</span> <span class="dt">False</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>isElem <span class="dt">True</span> [<span class="dt">False</span>] <span class="op">==</span> <span class="dt">False</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>isElem <span class="dv">30</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>] <span class="op">==</span> <span class="dt">True</span></span></code></pre></div>
<p><strong>Task 4:</strong> Write a function <code>count</code> which counts occurrences of an element in a list. Its type should be as general as possible and it should return an <code>Integer</code>. As a hint, here is a type signature template:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">count ::</span> <span class="co">{- constraint -}</span> <span class="ot">=&gt;</span> <span class="co">{- element type -}</span> <span class="ot">-&gt;</span> <span class="co">{- list type -}</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span></code></pre></div>
<p>You will need to replace the comments with the appropriate types / type constraints.</p>
<p>Example test cases:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>count <span class="dv">10</span> [] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>count <span class="dv">10</span> [<span class="dv">10</span>] <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>count <span class="dv">1</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">42</span>, <span class="dv">1</span>] <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>count <span class="st">&quot;x&quot;</span> [<span class="st">&quot;xyz&quot;</span>, <span class="st">&quot;zyx&quot;</span>, <span class="st">&quot;xxx&quot;</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>count <span class="st">&quot;x&quot;</span> [<span class="st">&quot;x&quot;</span>, <span class="st">&quot;xxx&quot;</span>, <span class="st">&quot;x&quot;</span>] <span class="op">==</span> <span class="dv">2</span></span></code></pre></div>
<h2 id="binary-trees">Binary Trees</h2>
<p>In Haskell, we can specify a (polymorphic) binary tree as the following datatype:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>            <span class="op">|</span> <span class="dt">Empty</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>            <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>Here, the constructor <code>Node</code> takes 3 arguments: the left subtree, an element of type <code>a</code> and the right subtree. The constructor <code>Empty</code> represents an empty tree. For example, the tree</p>
<pre><code>    3
   / \
  5   6
       \
        8</code></pre>
<p>is represented as</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>  <span class="dt">Node</span> (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">5</span> <span class="dt">Empty</span>) </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>       <span class="dv">3</span> </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>       (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">6</span> (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">8</span> <span class="dt">Empty</span>))</span></code></pre></div>
<p><strong>Task 5</strong>: Copy the above definition of <code>Tree</code> into your submission file. Transcribe the following tree into Haskell:</p>
<pre><code>             18
            /  \
           /    \
          /      \   
         15      20    
        /  \     /    
      40   50   8 
     /  \        \
    30  50        13</code></pre>
<p>Use the following template to include the tree in your submission file:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">tree1 ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>tree1 <span class="ot">=</span> <span class="co">{- insert your answer here -}</span></span></code></pre></div>
<p><strong>Task 6:</strong> Write a function inOrder, which performs an <a href="https://www.tutorialspoint.com/data_structures_algorithms/tree_traversal.htm">in-order traversal</a> of the tree and returns all the elements as a list. The function should have the following type:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">inOrder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>Example test cases:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>inOrder <span class="dt">Empty</span> <span class="op">==</span> []</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>inOrder (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">4</span> <span class="dt">Empty</span>) <span class="op">==</span> [<span class="dv">4</span>]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>inOrder (<span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">1</span> <span class="dt">Empty</span>) <span class="dv">2</span> <span class="dt">Empty</span>) <span class="dv">3</span> (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">4</span> (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">5</span> <span class="dt">Empty</span>)))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  <span class="op">==</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>inOrder tree1 <span class="op">==</span> [<span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>, <span class="dv">15</span>, <span class="dv">50</span>, <span class="dv">18</span>, <span class="dv">8</span>, <span class="dv">13</span>, <span class="dv">20</span>]</span></code></pre></div>
<p>Hint: You might want to refresh your memory on the <code class="sourceCode haskell"><span class="op">++</span></code> operator.</p>
<hr />
        </main>
  <!--<div id="statcounter_image" style="display:inline;"><a
       title="free hit counter"
       href="http://statcounter.com/free-hit-counter/"
       class="statcounter"><img
       src="http://c.statcounter.com/10419673/0/67e2ca33/1/"
       alt="free hit counter" style="border:none;" /></a></div>-->
</body>

