<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ferdinand Vesely" />
  <title>Programming Languages</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../../../css/foghorn.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  
  
  
  
  
  
  
  
  
  
  
</head>
<body>
<header id="title-block-header">
<h1 class="title">Programming Languages</h1>
<p class="subtitle">Lecture Notes for CS4400/5400</p>
<p class="author">Ferdinand Vesely</p>
</header>
<h1 id="lambda-calculus">Lambda Calculus</h1>
<p>Lambda calculus is a theory of functions. What is a function? There are two basic views one can take when characterizing them:</p>
<ol type="1">
<li>Function as a graph</li>
<li>Function as a value</li>
</ol>
<p>Considering a function <span class="math inline">\(f\)</span> as a graph is to consider it as a set of pairs – mappings between input and output values <span class="math inline">\((x, f(x))\)</span>. For example the square function on natural numbers <span class="math inline">\(^2 : \mathbb{N} \to \mathbb{N}\)</span> can be characterized as a set of pairs <span class="math inline">\((n, n^2)\)</span>:</p>
<p><span class="math display">\[
  \{ (0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), ... \}
\]</span></p>
<p>Using a function as a graph is to find an output that corresponds to our input. The alternative view to take is to consider a function as rules – equations, which tell us how to compute the output of the function from its input. For example, the square function <span class="math inline">\(^2 : \mathbb{N} \to \mathbb{N}\)</span> is defined by the equation:</p>
<p><span class="math display">\[
  n^2 = n \times n
\]</span></p>
<p>How do we use this function? We <em>substitute</em> an expression that looks like the left-hand side with the right-hand side, replacing the <em>argument</em> <span class="math inline">\(n\)</span> with the expression and then computing the resulting expression. For example, our calculation might proceed as follows:</p>
<p><span class="math display">\[
  \begin{aligned}
    {4^2}^2 + 3^2 
      &amp;= (4 \times 4)^2 + 3^2\\
      &amp;= \left((4 \times 4) \times (4 \times 4)\right) + 3^2\\
      &amp;= \left((4 \times 4) \times (4 \times 4)\right) + (3 \times 3)\\
%      &amp;= \left(16 \times (4 \times 4)\right) + (3 \times 3)\\
%      &amp;= \left(16 \times (4 \times 4)\right) + 9\\
%      &amp;= \left(16 \times 16\right) + 9\\
%      &amp;= 256 + 9\\
      &amp;... \\
      &amp;= 265
  \end{aligned}
\]</span></p>
<p>Or, as follows: <span class="math display">\[
  \begin{aligned}
    {4^2}^2 + 3^2 
      &amp;= (4 \times 4)^2 + 3^2\\
      &amp;= 16^2 + 3^2\\
      &amp;= 16^2 + 9\\
      &amp;= 256 + 9\\
      &amp;... \\
      &amp;= 265
  \end{aligned}
\]</span></p>
<p>In any case, the important thing to note is that we replace any occurrence of <span class="math inline">\(n^2\)</span> for any <span class="math inline">\(n\)</span> using the defining equation. In general, if we define a function <span class="math inline">\(f\)</span> by the equation <span class="math inline">\(f(x) = E\)</span>, where <span class="math inline">\(E\)</span> is some mathematical expression (potentially containing <span class="math inline">\(x\)</span>), then we use (apply) this function by replacing any occurrence of <span class="math inline">\(f(D)\)</span> (where <span class="math inline">\(D\)</span> is a mathematical expression) by <span class="math inline">\(E[x := D]\)</span>, that is the expression <span class="math inline">\(E\)</span> where all occurrences of <span class="math inline">\(x\)</span> are replaced by <span class="math inline">\(D\)</span>. This is called <em>substitution</em> of a variable <span class="math inline">\(x\)</span> in an expression <span class="math inline">\(E\)</span> for another expression <span class="math inline">\(D\)</span>. E.g., if</p>
<p><span class="math display">\[
  f(x) = x + x
\]</span></p>
<p>then:</p>
<p><span class="math display">\[
  \begin{aligned} 
  f(20) + f(2 \times 3) 
    &amp;= (x + x)[x := 20] + (x + x)[x := 2 \times 3] \\
    &amp;= (20 + 20) + ((2 \times 3) + (2 \times 3)) \\
    ...           
  \end{aligned}
\]</span> The next question is, how important is the name of the function? We use names as mnemonics, so that we can say we can</p>
<ol type="1">
<li>say “let <span class="math inline">\(f\)</span> be the function defined by the equation <span class="math inline">\(f(x) = E\)</span>” (where <span class="math inline">\(E\)</span> is an arbitrary mathematical expression), and</li>
<li>replace any occurrence of <span class="math inline">\(f\)</span> applied to an argument with an instance of <span class="math inline">\(E\)</span> where <span class="math inline">\(x\)</span> is replaced with the argument expression.</li>
</ol>
<p>We can do this without inventing names, by using functions as anonymous objects – just like we easily use numbers or strings or arrays. In mathematics an anonymous function will be written as <span class="math inline">\(x \mapsto E\)</span>. For example, the square function is <span class="math inline">\(x \mapsto x \times x\)</span>, the above function <span class="math inline">\(f\)</span> is <span class="math inline">\(x \mapsto x + x\)</span>.</p>
<p>The above exposition applies to programming too. Basically, all sensible “higher-level” programming languages allow us to define functions to abstract a computation by replacing a concrete expression with a variable – a placeholder. In Python we might write:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="cf">return</span> x <span class="op">*</span> x</span></code></pre></div>
<p>In C/C++:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">int</span> square(<span class="dt">int</span> x) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="cf">return</span> x * x; </span>
<span id="cb2-3"><a href="#cb2-3"></a>}</span></code></pre></div>
<p>In Haskell:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">square ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<p>In Scheme:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1"></a>(<span class="ex">define</span><span class="fu"> </span>(square x)</span>
<span id="cb4-2"><a href="#cb4-2"></a>  (* x x))</span></code></pre></div>
<p>In any programming language we operate with the rough understanding that whenever <code>square</code> is invoked with an argument, that application might as well be replaced with the body of the function with the argument variable replaced with the actual argument (either before or after evaluating the argument itself). More and more programming languages, particularly those which allow passing functions as arguments, allow creating functions without naming them – so called anonymous functions. Python and Scheme have <code>lambda</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">lambda</span> x : x <span class="op">*</span> x</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1"></a>(<span class="kw">lambda</span> (x) (* x x))</span></code></pre></div>
<p>OCaml has <code>fun</code> or <code>function</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">fun</span> x =&gt; x * x</span></code></pre></div>
<p>Haskell has the backslash:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>\x <span class="ot">-&gt;</span> x <span class="op">*</span> x</span></code></pre></div>
<p>C++ has, well…</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a>[](<span class="dt">int</span> x){ <span class="cf">return</span> x * x; }</span></code></pre></div>
<p>As hinted by the Scheme and Python examples, Lambda calculus is the underlying theory behind these anonymous functions. In its pure form, it is exclusively concerned with what it means to apply an abstracted expression (as an anonymous function), to an argument. It studies this as a purely syntactic operation.</p>
<p>Where Python and Scheme have <code>lambda</code>, OCaml has <code>fun</code> and <code>function</code>, Lambda calculus has <span class="math inline">\(\lambda\)</span>. That is an anonymous function with the formal parameter <span class="math inline">\(x\)</span> is constructed using <span class="math inline">\(\lambda x...\)</span> We can write the squaring function in lambda notation as</p>
<p><span class="math display">\[\lambda x.\ x \times x\]</span></p>
<p>We say that this is a <em>lambda abstraction</em> that <em>binds</em> the variable <span class="math inline">\(x\)</span> in <span class="math inline">\(x \times x\)</span>. In other words, <span class="math inline">\(x\)</span> is bound in <span class="math inline">\(x \times x\)</span>. An application is written (similarly to Scheme, OCaml, or Haskell) by writing the function and argument next to each other (juxtaposition). For example, where in Scheme we could write</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1"></a>((<span class="kw">lambda</span> (x) (* x x)) <span class="dv">10</span>)</span></code></pre></div>
<p>and in Haskell</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a>(\x <span class="ot">-&gt;</span> x <span class="op">*</span> x) <span class="dv">10</span></span></code></pre></div>
<p>In lambda notation we write:</p>
<p><span class="math display">\[
(\lambda x.\ x \times x)\ 10
\]</span></p>
<p>As I mentioned before, Lambda calculus looks at the application of a function as a syntactic operation, in terms of <em>substitution</em>, as the process of replacing any occurrence of the abstracted variable with the actual argument. For the above, this is replacing any occurrence of <span class="math inline">\(x\)</span> in <span class="math inline">\(x \times x\)</span> with <span class="math inline">\(10\)</span>:</p>
<p><span class="math display">\[
  \begin{aligned}
  (\lambda x.\ x \times x)\ 10
    &amp;= (x \times x)[x := 10]\\
    &amp;= 10 \times 10
  \end{aligned}
\]</span></p>
<p>Another way of thinking about the bound variable <span class="math inline">\(x\)</span> in the <span class="math inline">\(\lambda x.\ x \times x\)</span> as a placeholder or hole, where the argument “fits”.</p>
<p><span class="math display">\[
  (\lambda \boxed{\phantom{x}}.\ \boxed{\phantom{x}} \times \boxed{\phantom{x}})\ 10
    = \boxed{10} \times \boxed{10}
\]</span></p>
<h2 id="pure-lambda-calculus">Pure Lambda Calculus</h2>
<p>Here, we will look at the formal theory of pure Lambda Calculus. We will look at the syntax and a notion of computation.</p>
<h3 id="syntax">Syntax</h3>
<p>The basic syntax of the calculus is really simple:</p>
<pre><code>  &lt;Lambda&gt; ::= &lt;Variable&gt;
             | ( &lt;Lambda&gt; &lt;Lambda&gt; )
             | ( λ &lt;Variable&gt; . &lt;Lambda&gt; )</code></pre>
<p>That is all there really is:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<ul>
<li>variable reference, e.g. <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span>, <span class="math inline">\(a\)</span>, <span class="math inline">\(\mathit{square}\)</span></li>
<li>application, e.g., <span class="math inline">\((x\ y)\)</span>, <span class="math inline">\(((\lambda x.\ x)\ (\lambda x.\ x))\)</span></li>
<li>lambda abstraction, e.g.,
<ul>
<li><span class="math inline">\((\lambda x.\ x)\)</span> – expressing the identity function</li>
<li><span class="math inline">\((\lambda x.\ x\ x)\)</span> – a function that applies its argument to itself</li>
</ul></li>
</ul>
<p>You might ask: what can we do with such a minuscule language? Turns out a lot. As proven by A.M. Turing, this pure version of Lambda calculus is equivalent in computational power to Turing Machines. That means we are able to build up a programming language out of these three constructs. We will look at how to do that in the section on <a href="#programming-in-pure-lambda-calculus">Programming in Pure Lambda Calculus</a> below.</p>
<h4 id="syntax-conventions-and-terminology">Syntax Conventions and Terminology</h4>
<p>Terminology: Take a lambda abstraction:</p>
<p><span class="math display">\[
  (\lambda x.\ N)
\]</span></p>
<ol type="1">
<li><span class="math inline">\(\lambda x\)</span> is a <em>binder</em> binding <span class="math inline">\(x\)</span></li>
<li><span class="math inline">\(N\)</span> is the <em>body</em> of the abstraction</li>
</ol>
<p>To avoid writing too many parentheses, these conventions are usually taken for granted:</p>
<ol type="1">
<li>Outermost parentheses are usually dropped: <code>x x</code>, <code>λx. x</code>.</li>
<li>Application <em>associates to the left</em>. That is, <code>(((a b) c) d)</code> is the same as <code>((a b c) d)</code> is the same as <code>(a b c d)</code>, which is the same as <code>a b c d</code> (see previous rule).</li>
<li>Lambda abstraction bodies extend as far to the right as possible. That is, <code>(λa. (λb. ((a b) c)))</code> is the same as <code>λa. λb a b c</code>.</li>
</ol>
<h3 id="beta-reduction">Beta Reduction</h3>
<p>Computation in pure lambda calculus is expressed in a single rule: the <span class="math inline">\(\beta\)</span>-reduction rule:</p>
<p><span class="math display">\[
  (\lambda x.\ M)\ N \longrightarrow_\beta M[x := N]
\]</span></p>
<p>The long arrow stands for “reduces to”. On the left-hand side, we have an application of a lambda abstraction to an arbitrary term. On the right-hand side, we substitute the abstraction’s bound variable with the argument. A term that matches the pattern on the left-hand side (that is, a lambda abstraction applied to something) is called a <em>redex</em>, short for <em>reducible expression</em>. For example:</p>
<ul>
<li><code>(λx. x) a --&gt;β a</code></li>
<li><code>(λx. x x) (λy. y) --&gt;β (λy. y) (λy. y)</code></li>
<li>the above reduces further: <code>(λy. y) (λy. y) --&gt;β (λy. y)</code></li>
<li>not a redex: <code>(x x)</code></li>
<li>also not a redex: <code>x (λy. y)</code></li>
<li>also not a redex: <code>(λy. (λx. x) y)</code>, although it does contain a redex <code>((λx. x) y)</code></li>
</ul>
<h3 id="variables-bound-free.-closed-expressions">Variables: Bound, Free. Closed Expressions</h3>
<p>We have already mentioned the notion of a bound variable. A variable is said to be <em>bound</em> in an expression, if it appears under a λ-abstraction binding that particular variable. Or, in other words, it is bound if it appears in the scope of a binder. For example:</p>
<ul>
<li><code>x</code> is bound in <code>(λx. x x)</code> – it appears in the scope of the binder <code>λx</code></li>
<li>both <code>x</code> and <code>y</code> are bound in <code>(λx. λy. x y)</code> – <code>x</code> appears in the scope of <code>λx</code>, <code>y</code> in the scope of <code>λy</code></li>
<li><code>x</code> is <em>not</em> bound in <code>(λy. x y)</code>, but <code>y</code> is – <code>x</code> does not appear in the scope of any binder here, while <code>y</code> appears in the scope of <code>λy</code></li>
</ul>
<p>A <em>free</em> variable is one which appears in a position where it is not bound. For example:</p>
<ul>
<li><code>x</code> is free in <code>x x</code>, in <code>λy. x y</code>, or in <code>(λy. y y) x</code></li>
<li><code>x</code> is <em>not</em> free in <code>(λx. x x) (λx. x)</code></li>
<li><code>x</code> is <em>both</em> bound and free in <code>(λx. x y) x</code>, while <code>y</code> is only free</li>
</ul>
<p>As you can see above, a variable might be both bound and free in an a expression.</p>
<p>An expression which contains no free variables is <em>closed</em>, for example:</p>
<ul>
<li><code>λx. x</code></li>
<li><code>λx. λy. x y x</code></li>
</ul>
<p>A closed lambda expression is also called a <em>combinator</em>.</p>
<p>A variable is called <em>fresh</em> for an expression, if it does not appear free in that expression. For example, <code>x</code> is fresh for <code>y z</code> or <code>(λx. x x)</code>.</p>
<h3 id="names-of-bound-variables-dont-matter">Names of Bound Variables Don’t Matter</h3>
<p>Intuitively, an identity function should be an identity function, no matter what we choose to name its bound variable. That is, <code>(λx. x)</code> should be considered the same as <code>(λy. y)</code> or <code>(λz. z)</code>. This is captured in the notion of alpha equivalence: two expressions are <em>α-equivalent</em>, if they only differ in the names of their bound variables. This also means, that we are free to <em>α-convert</em> any lambda term by consistently renaming bound variables. However, the new names must differ from free variables under the particular binder. We are thus free to convert <code>(λx. x)</code> to, e.g., <code>(λa. a)</code>; <code>(λy. z y)</code> to <code>(λx. z x)</code>, but not to <code>(λz. z z)</code>.</p>
<h3 id="substitution">Substitution</h3>
<p>We were happy to use substitution in an informal manner up until now:</p>
<blockquote>
<p><span class="math inline">\(M[x := N]\)</span> means replacing occurrences of the variable <span class="math inline">\(x\)</span> in the expression <span class="math inline">\(M\)</span> with the expression <span class="math inline">\(N\)</span>.</p>
</blockquote>
<p>Here we want to pin it down. For that, we will need to consider the difference between bound and free variables. Let’s try to start with a naive definition of substitution.</p>
<h4 id="naive-substitution">Naive Substitution</h4>
<p>There are three syntactic forms, we need to consider each form:</p>
<p>Variable: <code>x[y := N] = ?</code></p>
<p>Application: <code>(M1 M2)[y := N] = ?</code></p>
<p>Abstraction: <code>(λx. M)[y := N] = ?</code></p>
<p>Variables are straightforward: we either find the variable to be substituted or we find a different one:</p>
<ol type="1">
<li><p><code>y[y := N] = N</code></p></li>
<li><p><code>x[y := N] = x</code> if <code>x</code> <span class="math inline">\(\neq\)</span> <code>y</code></p></li>
</ol>
<p>Application is also relatively simple – we simply substitute in both left-hand and right-hand side:</p>
<ol start="3" type="1">
<li><code>(M1 M2)[y := N] = (M1[y := N] M2[y := N])</code></li>
</ol>
<p>Now, for a lambda abstraction we need to consider the variables involved. We certainly don’t want to override the bound variable of a function:</p>
<ol start="4" type="1">
<li><code>(λy. M)[y := N] = (λy. M)</code></li>
</ol>
<p>The remaining case seems simple enough too:</p>
<ol start="5" type="1">
<li><code>(λx. M)[y := N] = (λx. M[y := N])</code> if <code>x</code> <span class="math inline">\(\neq\)</span> <code>y</code></li>
</ol>
<p>If we test this substitution everything seems to be okay:</p>
<pre><code>  (x x)[x := (λy. y)] = (x[x := (λy. y)] x[x := (λy. y)])
                      = (λy. y) (λy. y)

  ((λx. x y) x)[x := (λy. y)] = (λx. x y)[x := (λy. y)] x[x := (λy. y)]
                              = (λx. x y) (λy. y)</code></pre>
<p>However, what happens if the expression that we are substituting contains the bound variable?</p>
<pre><code>  (λy. x)[x := y] = λy. y</code></pre>
<p>We see that in this case, we have just “captured” variable <code>y</code> and changed its status from free to bound. This changes the meaning of a variable – whereas the original meaning of <code>y</code> was given by the context of the left-hand side expression, now it is given by the binder <code>λy</code>. In particular, we changed a constant function—which, after the substitution should return a free <code>y</code>, no matter what argument it is applied to—to an identity function, that just returns whatever its argument is.</p>
<p>From this we see that we need substitution to behave differently when there the expression that we are trying to substitute, contains free variables that clash with variables bound by a lambda-abstraction.</p>
<h4 id="safe-substitution">Safe Substitution</h4>
<p>To fix this we can restrict when the last case of our substitution applies:</p>
<ol start="5" type="1">
<li><code>(λx. M)[y := N] = (λx. M[y := N])</code> if <code>x</code> <span class="math inline">\(\neq\)</span> <code>y</code> and if <code>x</code> is not free in <code>N</code></li>
</ol>
<p>Now our substitution is “safe”. However, this turns it into a partial function – it is left undefined for cases where the bound variable <code>x</code> appears free in <code>N</code>. To go around this, we can make use of alpha-conversion: we consistently rename the bound variable <code>x</code> to one that doesn’t clash with <code>y</code> or the free variables in <code>N</code> or <code>M</code>. Only then do we perform the actual substitution of <code>y</code>.</p>
<ol start="5" type="1">
<li><code>(λx. M)[y := N] = (λx'. M[x := x'][y := N])</code> if <code>x</code> <span class="math inline">\(\neq\)</span> <code>y</code> and <code>x'</code> is fresh for <code>y</code>, <code>N</code> and <code>M</code></li>
</ol>
<p>Now substitution is a total function again. For an implementation, we just need to know how to pick a fresh variable. Notice how we replace the bound variable <code>x</code> with <code>x'</code> and also rename any ocurrence of <code>x</code> to <code>x'</code> in the body <code>M</code>. Since <code>x'</code> is chosen so that it does not appear free in <code>M</code> or <code>N</code>, we are avoiding any potential clashes.</p>
<h3 id="reduction-strategies">Reduction Strategies</h3>
<p>Beta reduction tells us how to reduce a redex. The missing piece of the puzzle is how to decide where to look for a redex and apply the beta-reduction rule. This is given by reduction strategies.</p>
<p>(The following text is taken, with minor modifications, from <em>Types and Programming Languages</em>)</p>
<h4 id="full-beta-reduction">Full Beta-Reduction</h4>
<p>Under this strategy, any redex may be reduced at any time. At each step we pick some redex, anywhere inside the term we are evaluating, and reduce it. For example, consider the term:</p>
<pre><code>(λa. a) ((λb. b) (λz. (λc. c) z))</code></pre>
<p>This term contains three redexes:</p>
<ul>
<li><code>(λa. a) ((λb. b) (λz. (λc. c) z))</code></li>
<li><code>(λb. b) (λz. (λc. c) z)</code></li>
<li><code>(λc. c) z</code></li>
</ul>
<p>Under full beta-reduction, we might choose, for example, to begin with the innermost redex, then do the one in the middle, then the outermost:</p>
<p>U+10FC74</p>
<pre><code>(λa. a) ((λb. b) (λz. (λc. c) z))
  --&gt; (λa. a) ((λb. b) (λz. z))
  --&gt; (λa. a) (λz. z)
  --&gt; λz. z</code></pre>
<p><code>λz. z</code> cannot be reduced any further and is a <em>normal form</em>.</p>
<p>Note, that under full beta-reduction, each reduction step can have more than possible one result, depending on which redex is chosen.</p>
<h4 id="normal-order">Normal Order</h4>
<p>Under normal order, the leftmost, outermost redex is always reduced first. Our example would be reduced as follows:</p>
<pre><code>(λa. a) ((λb. b) (λz. (λc. c) z))
  --&gt; (λb. b) (λz. (λc. c) z)
  --&gt; λz. (λc. c) z
  --&gt; λz. z</code></pre>
<p>Again, <code>λz. z</code> is the normal form and cannot be reduced further.</p>
<p>Because each redex is chosen in a deterministic manner, each reduction step has one possible result – reduction thus becomes a (partial) function.</p>
<h4 id="call-by-name">Call by Name</h4>
<p>Call by name puts more restrictions on which redexes are fair game, and disallows reductions inside abstractions. For our example, we perform the same reduction steps as normal form, but stop short of “going under” the last abstraction.</p>
<pre><code>(λa. a) ((λb. b) (λz. (λc. c) z))
  --&gt; (λb. b) (λz. (λc. c) z)
  --&gt; λz. (λc. c) z</code></pre>
<p>Haskell uses an optimization of call by name, called call by need or lazy evaluation. Under call by name based strategies, arguments are only evaluated if they are needed.</p>
<h4 id="call-by-value">Call by Value</h4>
<p>Under call by value, only outermost redexes are reduced and each redex is only reduce after its right-hand side has been fully reduced to a normal form.</p>
<pre><code>(λa. a) ((λb. b) (λz. (λc. c) z))
  --&gt; (λa. a) (λz. (λc. c) z)
  --&gt; λz. (λc. c) z</code></pre>
<p>Evaluation strategies based on call by value are used by the majority of languages: an argument expression is evaluated to a value before it is passed into the function as an argument. Such a strategy is also called <em>strict</em>, because it strictly evaluates all arguments, regardless of whether they are used.</p>
<h2 id="programming-in-pure-lambda-calculus">Programming in Pure Lambda Calculus</h2>
<h3 id="multiple-arguments">Multiple Arguments</h3>
<p>So far, we have looked at lambda abstractions which only take a single argument. However, unary functions are only a small part of our experience with programming. We use functions with multiple arguments all the time. How do we pass more than one argument to a lambda?</p>
<p>One approach would be to extend the calculus with a notion of tuples. Perhaps throw in some pattern matching, for good measure:</p>
<p><span class="math display">\[
  (\lambda (x, y).\ x\ y)\ (a, b)
\]</span></p>
<p>However, this means that we are abandoning the very minimal core lambda calculus with all its simplicity. And we don’t have to! As we know well by now, applying an abstraction simply replaces its bound variable with the argument that it’s applied to, as in this trivial example:</p>
<p><span class="math display">\[
  (\lambda x. x\ y)\ b \longrightarrow (x\ y)[x := b] = (b\ y)
\]</span></p>
<p>What happens if the abstraction actually just returns another abstraction.</p>
<p><span class="math display">\[
\begin{aligned}
  (\lambda x.\ (\lambda y.\ x\ y))\ b \longrightarrow (\lambda y.\ x\ y)[x := b]
  = (\lambda y.\ b\ y)
\end{aligned}
\]</span></p>
<p>Since neither of the bound variable of the inner abstraction (<span class="math inline">\(y\)</span>) and the variable we are substituting for (<span class="math inline">\(x\)</span>), nor the bound variable of the inner abstraction (<span class="math inline">\(y\)</span>) and the term we are substituting (<span class="math inline">\(b\)</span>) are in conflict, we simply substitute <span class="math inline">\(x\)</span> for <span class="math inline">\(b\)</span> <em>inside</em> the inner abstraction. This yields an abstraction which can be applied to another argument. That is applying <span class="math inline">\((\lambda x.\ (\lambda y.\ x\ y))\)</span> to <span class="math inline">\(b\)</span> returned an abstraction which is “hungry” for another argument. We can now apply that abstraction to another argument:</p>
<p><span class="math display">\[
(\lambda y.\ b\ y)\ a \longrightarrow (b\ y)[y := a] = b\ a
\]</span></p>
<p>Let’s do the same in one expression:</p>
<p><span class="math display">\[
\begin{aligned}
  (((\lambda x.\ (\lambda y.\ x\ y))\ b)\ a 
  &amp;\longrightarrow ((\lambda y.\ x\ y)[x := b])\ a \\
  &amp;= (\lambda y.\ b\ y)\ a \\
  &amp;\longrightarrow (b\ y)[y := a]\\
  &amp;= (b\ a)
\end{aligned}
\]</span></p>
<p>We just applied an abstraction to two arguments. To make this a little easier to see, we can use left-associativity of application and the fact that the scope of a binder goes as far right as possible to rewrite the original expression as</p>
<p><span class="math display">\[
  (\lambda x.\ \lambda y.\ x\ y)\ b\ a
\]</span></p>
<p>This technique is called <em>currying</em> (after <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>, although he was not the first one to come up with it). It is so common that, usually a short-hand is introduced for abstractions with more than one argument:</p>
<p><span class="math display">\[
\begin{aligned}
  (\lambda x\ y.\ ...) &amp;\equiv (\lambda x.\ \lambda y.\ ...)\\
  (\lambda x\ y\ z.\ ...) &amp;\equiv (\lambda x.\ \lambda y.\ \lambda z.\ ...)\\
  \text{etc.}
\end{aligned}
\]</span></p>
<p>If we allow arithmetic in our lambda expressions a nice example will be:</p>
<p><span class="math display">\[
\begin{aligned}
  \left(\lambda x\ y.\ \frac{x + y}{y}\right) 4\ 2 
  &amp;\longrightarrow \left(\lambda y.\ \frac{4 + y}{y}\right) 2 \\
  &amp;\longrightarrow \frac{4 + 2}{2}
\end{aligned}
\]</span></p>
<p>Currying is used as the default for functions of multiple arguments by Haskell and OCaml (determined mostly by their standard libraries). On the other hand, Standard ML’s library uses tuples as default.</p>
<h3 id="data-types">Data types</h3>
<p>We see that we can represent functions with multiple arguments in PLC. Surely, for representing other kinds of data (such as booleans, numbers, data structures), we need to introduce extensions and add these as primitive operations? Not really…</p>
<h4 id="booleans">Booleans</h4>
<p>Many types of values can be represented using <em>Church encodings</em>. Booleans are probably the simplest and most straightforward:</p>
<p><span class="math display">\[
\begin{aligned}
  \mathsf{true} &amp;= \lambda t\ f.\ t &amp;\qquad&amp;(= \lambda t.\ \lambda f.\ t)\\
  \mathsf{false} &amp;= \lambda t\ f.\ f &amp; &amp;(= \lambda t.\ \lambda f.\ f)\\
\end{aligned}
\]</span></p>
<p>What do these mean? The representation of <span class="math inline">\(\mathsf{true}\)</span> is a function that takes two arguments and returns the first one. On the other hand, <span class="math inline">\(\mathsf{false}\)</span> returns its second argument. To make sense of these, we need to put them to work and see how they work with boolean operations.</p>
<p>We start with the conditional: <span class="math inline">\(\textsf{if-else}\)</span>. It should take three arguments and return its second one if the first one evaluates to <span class="math inline">\(\textsf{true}\)</span>, and its third argument otherwise. That is we are looking for an expression:</p>
<p><span class="math display">\[
  \textsf{if-then}\ \textsf{true}\ x\ y \longrightarrow ... \longrightarrow x
\]</span></p>
<p>and</p>
<p><span class="math display">\[
  \textsf{if-then}\ \textsf{false}\ x\ y \longrightarrow ... \longrightarrow y
\]</span></p>
<p>Notice something?</p>
<p><span class="math display">\[
\begin{aligned}
  \textsf{true}\ x\ y &amp;\longrightarrow x\\
  \textsf{false}\ x\ y &amp;\longrightarrow y
\end{aligned}
\]</span></p>
<p>That means that all <span class="math inline">\(\textsf{if-then}\)</span> needs to do is to apply its first argument to its second and third argument, since the boolean representation takes care of the selection itself:</p>
<p><span class="math display">\[
  \textsf{if-then} = \lambda b\ t\ f.\ b\ t\ f
\]</span></p>
<p>What about boolean operations?</p>
<!--$$
\begin{aligned}
  \textsf{and}\ \textsf{true}\ \textsf{true} &\longrightarrow ... \longrightarrow \textsf{true}\\
  \textsf{and}\ \textsf{false}\ \textsf{true} &\longrightarrow ... \longrightarrow \textsf{false}\\
  \textsf{and}\ \textsf{true}\ \textsf{false} &\longrightarrow ... \longrightarrow \textsf{false}\\
  \textsf{and}\ \textsf{false}\ \textsf{false} &\longrightarrow ... \longrightarrow \textsf{false}
\end{aligned}
$$-->
<p>Let’s try to look at conjunction: <code>and</code>. We look for <code>???</code> to put in:</p>
<pre><code>(λa b. ???) true true   --&gt; ... --&gt; true
(λa b. ???) true false  --&gt; ... --&gt; false
(λa b. ???) false true  --&gt; ... --&gt; false
(λa b. ???) false false --&gt; ... --&gt; false</code></pre>
<p>First note that <code>true true x --&gt; true</code> for any <span class="math inline">\(x\)</span>, so it seems that <code>λa b. a b x</code> could work if we find an appropriate <span class="math inline">\(x\)</span>:</p>
<pre><code>(λa b. a b x) true true --&gt; (λb. true b x) true --&gt; true true x --&gt; ... --&gt; true</code></pre>
<p>Now note that in all but the first case <code>and</code> should reduce to <code>false</code>. In the second case,</p>
<pre><code>(λa b. a b x) true false --&gt; ... --&gt; true false x --&gt; ... --&gt; false</code></pre>
<p>for any <span class="math inline">\(x\)</span>, so that still works. Now, how can we get <code>false true x --&gt; false</code>? By taking <span class="math inline">\(x\)</span> to be <code>false</code>:</p>
<pre><code>(λa b. a b false) false true --&gt; ... --&gt; false true false --&gt; ... --&gt; false</code></pre>
<p>The final case also works:</p>
<pre><code>(λa b. a b false) false false --&gt; ... --&gt; false false false --&gt; ... --&gt; false</code></pre>
<p>Hence <span class="math display">\[
  \textsf{and} = \lambda a\ b.\ a\ b\ \textsf{false}
\]</span></p>
<p>Another way of thinking about the definition of <code>and</code> is to define it terms of if-then-else. E.g., in Haskell,</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="fu">and</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="fu">and</span> a b <span class="ot">=</span> <span class="kw">if</span> a <span class="kw">then</span> b <span class="kw">else</span> <span class="dt">False</span></span></code></pre></div>
<p>which just says that if the first argument is true then the result of <code class="sourceCode haskell"><span class="fu">and</span></code> depends on the second one, and if its false the result will be false regardless of the second argument.</p>
<p>Based on this, we can express the and operation using <code>if-else</code>, which we defined above, and show that it is equivalent to the previous definition by simplifying it using normal order reduction:</p>
<pre><code>and =   λa b. if-else a b false
    =   λa b. (λb t f. b t f) a b false
    --&gt; λa b. (λt f. a t f) b false
    --&gt; λa b. (λf. a b f) false
    --&gt; λa b. a b false</code></pre>
<p>Can you come up with a representation of <span class="math inline">\(\textsf{or}\)</span>? <span class="math inline">\(\textsf{not}\)</span>?</p>
<h4 id="pairs">Pairs</h4>
<p>Pairs can be encoded using an abstraction which “stores” its two arguments:</p>
<pre><code>pair = λl r s. s l r</code></pre>
<p>You can think of a <code>s</code> as a “chooser” function which either picks <code>l</code> or <code>r</code>. Selectors for the first and second element are then, respectively, defined as:</p>
<pre><code>fst = λp. p (λl r. l)
snd = λp. p (λl r. r)</code></pre>
<p>Take a look at the selector functions we pass to the pair representation. Are they familiar? (Hint: booleans)</p>
<h4 id="natural-numbers-church-numerals">Natural Numbers: Church Numerals</h4>
<p>Natural numbers are Church-encoded as Church numerals:</p>
<pre><code>zero = λs z. z
one = λs z. s z
two = λs z. s (s z)
three = λs z. s (s (s z))
...</code></pre>
<p>A numeral for <span class="math inline">\(n\)</span> can be understood as a function that takes some representation of a successor function and some representation of zero and applies the successor to zero <span class="math inline">\(n\)</span> times.</p>
<p>How about operations on numerals? The successor of a numeral <code>λs z...</code> is computed by inserting one more application of <code>s</code> inside of the abstraction:</p>
<pre><code>succ (λs z. z) --&gt; ... --&gt; λs z. s z
succ (λs z. s z) --&gt; ... --&gt; λs z. s (s z)
succ (λs z. s (s z)) --&gt; ... --&gt; λs z. s (s (s z))
...</code></pre>
<p>We know that <code>succ</code> takes a numeral (which is an abstraction) and returns another numeral, which is again an abstraction:</p>
<pre><code>succ = λn. (λs z. ...n...)</code></pre>
<p>Taking <code>λs z. z</code> as an example input:</p>
<pre><code>(λn. (λs z. ...n...)) (λs z. z) 
  --&gt; (λs z. ...(λs z. z)...)) 
  --&gt; (λs z. s z)</code></pre>
<p>We see that we need to apply an extra <code>s</code> <em>under</em> <code>λs z.</code>:</p>
<pre><code>(λs z. s ...(λs z. z)...) --&gt; ... --&gt; (λs z. s z)</code></pre>
<p>To do this we need to “open” the abstraction representing 0. This can be achieved by passing the outer <code>s</code> and <code>z</code> as arguments. We achieve what we wanted.</p>
<pre><code>(λs z. s ...(λs z. z) s z...) --&gt; (λs z. s ...z...) = (λs z. s z)</code></pre>
<p>Working backwards, we arrive at our successor function:</p>
<pre><code>(λs z. s z) 
  &lt;-- (λs z. s ((λs z. z) s z)) 
  &lt;-- (λn. λs z. s (n s z)) (λs z. z)
  = succ (λs z. z)</code></pre>
<p>Successor can be thus defined as:</p>
<pre><code>succ = λn. (λs z. s (n s z)) = λn s z. s (n s z)</code></pre>
<p>Once we have a successor operation, defining addition is quite simple if we keep in mind that a Church numeral <span class="math inline">\(m\)</span> applies its first argument (<code>s</code>) to its second argument (<code>z</code>) <span class="math inline">\(m\)</span> times:</p>
<pre><code>plus = λm n. m succ n</code></pre>
<!--```
plus = λm n. (λs z. m s (n s z))
```-->
<!--To understand this:
- `m` and `n` are functions that apply their first argument (`s`) to their second argument (`z`) $m$ and $n$ times
- Thus `n s z` applies `s` to `z` $n$ times
- Then the result of that is taken and `s` is applied to it $m$ times-->
<p>Multiplication follows the same principle:</p>
<p><span class="math display">\[
m * n = \underbrace{n + (... n}_{m \text{ times}} + 0)
\]</span></p>
<p>Hence:</p>
<pre><code>times = λm n. m (plus n) zero</code></pre>
<p>We can define subtraction via a predecessor function, which is surprisingly more tricky than the successor function. For a numeral <code>λs z. s (s ... (s z))</code>, the predecessor should return a numeral with one less <code>s</code>. One way of defining a predecessor is via a function that “counts” the number of <code>s</code> applications in a numeral, but also remembers the previous count, that is, one less than the total number of applications of <code>s</code>:</p>
<pre><code>pred = λn. snd (n (λp. pair (succ (fst p)) (fst p)) (pair zero zero))</code></pre>
<p>Here the numeral <code>n</code> (of which we want to compute the predecessor) is applied to two arguments:</p>
<ol type="1">
<li>The function <code>(λp. pair (succ (fst p)) (fst p))</code>. This function takes a pair (bound to <code>p</code>) containing two numerals. It returns a pair containing the successor of the first element of <code>p</code>, together with its original value. That means, everytime the function is applied to a pair containing numerals <code>n</code> and <code>m</code>, it returns a pair with numerals corresponding to <code>n + 1</code> and <code>n</code> (<code>m</code> is discarded).</li>
<li>A pair containing two zeros: <code>(pair zero zero)</code>.</li>
</ol>
<p>Finally, the second element of the pair is returned – which contains the count of <code>s</code> applications, except for the last one.</p>
<p>Here is an example. We let <code>f = (λp. pair (succ (fst p)) (fst p))</code></p>
<pre><code>pred three 
    = (λn. snd (n f (pair zero zero))) (λs z. s (s (s z)))
  --&gt; snd ((λs z. s (s (s z))) f (pair zero zero))
  --&gt; snd ((λz. f (f (f z))) (pair zero zero))
  --&gt; snd (f (f (f (pair zero zero))))
    = snd (f (f ((λp. pair (succ (fst p)) (fst p)) (pair zero zero))))
  --&gt; snd (f (f (pair (succ (fst (pair zero zero))) (fst (pair zero zero)))))
  --&gt; ...
  --&gt; snd (f (f (pair (succ (fst zero)) (fst zero zero))))
  --&gt; snd (f (f (pair (succ zero) zero)))
  --&gt; ...
  --&gt; snd (f (f (pair one zero)))
    = snd (f ((λp. pair (succ (fst p)) (fst p)) (pair one zero)))
  --&gt; snd (f (pair (succ (fst (pair one zero))) (fst (pair one zero))))
  --&gt; snd (f (pair (succ one) one))
  --&gt; ...
  --&gt; snd (f (pair two one))
  --&gt; ...
  --&gt; snd (pair (succ two) two)
  --&gt; ...
  --&gt; snd (pair three two)
  --&gt; ...
  --&gt; two</code></pre>
<p>To subtract <code>n</code> from <code>m</code>, we need to take 1 away from <code>m</code> <code>n</code> times.</p>
<pre><code>minus = λm n. n pred m</code></pre>
<p>For completeness, an alternative predecessor definition is as follows (TODO: explain):</p>
<pre><code>pred&#39; = λn f x. n (λg h. h (g f)) (λu. x) (λu. u)</code></pre>
<p>We can check if a variable is zero:</p>
<pre><code>is-zero = λn.n (λx. false) true</code></pre>
<p>We can define <span class="math inline">\(\leq\)</span></p>
<pre><code>leq = λm n. is-zero (minus m n)</code></pre>
<p>And we can define equality:</p>
<pre><code>equal = λm n. and (leq m n) (leq n m)</code></pre>
<h3 id="recursion">Recursion</h3>
<p>We have seen that we can define booleans, together with a conditional, and numbers, together with arithmetic operations in pure lambda calculus. However, to reach full Turing power, we lack one important ingredient: the ability to loop. To loop in a functional setting, we need the little brother of looping: self-reference.</p>
<p>To see that we can loop, let us look at a term, for which <span class="math inline">\(\beta\)</span>-reduction never terminates in a normal form. This interesting term, called <span class="math inline">\(\Omega\)</span>, is defined as follows:</p>
<pre><code>Ω = (λx. x x) (λx. x x)</code></pre>
<p>We see that we have an abstraction which applies its argument to itself and which is applied to itself. How does reduction proceed?</p>
<pre><code>(λx. x x) (λx. x x) --&gt; (x x)[x := (λx. x x)] 
  = (λx. x x) (λx. x x) --&gt; (x x)[x := (λx. x x)] 
  = (λx. x x) (λx. x x) --&gt; (x x)[x := (λx. x x)] 
  ...</code></pre>
<p>Immediately after the first reduction step, we are back where we started! Well, we see we can loop forever (diverge), but how is this useful?</p>
<p>In a programming language like OCaml, we are used to defining recursive functions which refer to themselves inside of their body:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact = <span class="kw">fun</span> n -&gt; </span>
<span id="cb48-2"><a href="#cb48-2"></a>  <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n * fact (n - <span class="dv">1</span>)</span></code></pre></div>
<p>How do we achieve this in lambda? While we have been freely using equations to define names for lambda expressions, these were just meta-definitions of names. That is, when we write</p>
<pre><code>fact = λn. if-true (is-zero n) one (mult n (?fact? (pred n)))</code></pre>
<p>we rely on our meta-language and our common understanding of it to replace any occurrence of <code>?fact?</code> with the right-hand side of the above equation, as many times as needed. But this is not beta-reduction, that is we are not defining a recursive function as an object in lambda calculus. To get there, we can think of a recursive definition as follows: “Assuming we have a function to call in the recursive case, we can complete the definition”. In Haskell or OCaml, we can simply assume that we already have the function that we are defining. But what is really going on here, is that we can abstract the recursive call as an argument – which corresponds to saying “assuming we already have a function to call in the recursive case”:</p>
<pre><code>fact = λf. λn. if-true (is-zero n) one (mult n (f (pred n)))</code></pre>
<p>Now factorial does not refer to itself anymore, we just need to give it a function to call in the else branch. Easy:</p>
<pre><code>fact = (λf. λn. if-true (is-zero n) one (mult n (f (pred n)))) (λn. if-true (is-zero n) one (mult n (f (pred n))))</code></pre>
<p>Wait, but now what about <code>f</code> in the second case? Ah, no problem:</p>
<pre><code>fact = (λf. λn. if-true (is-zero n) one (mult n (f (pred n)))) 
          ((λf. λn. if-true (is-zero n) one (mult n (f (pred n))))
            (λn. if-true (is-zero n) one (mult n (f (pred n))))) </code></pre>
<p>This apparently won’t work… unless we have a way of supplying an argument for <code>f</code> as many times as it’s needed. That is, a way to allow the function reference itself whenever it needs to. This is where <em>fixpoint combinators</em> come in.</p>
<p>In math, a fixed point of a function <span class="math inline">\(f\)</span> is an input for which the function returns the input itself:</p>
<p><span class="math display">\[
f(x) = x
\]</span></p>
<p>If the above holds, we say that <span class="math inline">\(x\)</span> is a fixed point of <span class="math inline">\(f\)</span>. A fixpoint combinator (in general called <span class="math inline">\(\operatorname{fix}\)</span>) is an operation that computes the fixed point of a function. That is, it is a function for which the following equation holds:</p>
<pre><code>fix f = f (fix f)</code></pre>
<p>This equation just spells out that when a function is applied to its fixpoint, the fixpoint shall be returned. Let’s use the above equation on itself, by replacing occurrences of <code>fix f</code> with the right-hand side:</p>
<pre><code>fix f = f (fix f)
      = f (f (fix f))
      = f (f (f (fix f)))
      = ...</code></pre>
<p>Now glance above: “If only we had a way of supplying an argument for <code>f</code> as many times as it’s needed.” Seems we are onto something. Let’s replace <code>f</code> with our factorial:</p>
<pre><code>fact = λf. λn. if-true (is-zero n) one (mult n (f (pred n)))
 
fix fact
  =   fact (fix fact)
  =   (λf. λn. if-true (is-zero n) one (mult n (f (pred n)))) (fix fact)
  --&gt; (λn. if-true (is-zero n) one (mult n ((fix fact) (pred n))))</code></pre>
<p>This looks promising. The problem? We haven’t <em>defined</em> what <code>fix</code> is, we are just abusing our meta-notation again. In fact, there is more than one possible definition of <code>fix</code>. The simplest one is the <em>Y</em> combinator:</p>
<pre><code>Y = λf. (λx. f (x x)) (λx. f (x x))</code></pre>
<p>Notice how the structure is very similar to <span class="math inline">\(\Omega\)</span> above. We should check if it is a fixpoint combinator, that is, if it satisfies the fixpoint equation:</p>
<pre><code>Y g = (λf. (λx. f (x x)) (λx. f (x x))) g
    = (λx. g (x x)) (λx. g (x x)))
    = g ((λx. g (x x)) (λx. g (x x)))
    = g ((λf. ((λx. f (x x)) (λx. f (x x)))) g)
    = g (Y g)</code></pre>
<p>We have ourselves a fixpoint combinator. Let us try to use it to define our factorial function:</p>
<pre><code>fact0 = (λf. λn. if-true (is-zero n) one (mult n (f (pred n))))
fact = Y fact0</code></pre>
<p>What happens when we try to apply <code>fact</code> to a numeral?</p>
<pre><code>fact three 
  =   Y fact0 three
  =   (λf. (λx. f (x x)) (λx. f (x x))) fact0 three
  --&gt; (λx. fact0 (x x)) (λx. fact0 (x x)) three
  --&gt; fact0 ((λx. fact0 (x x)) (λx. fact0 (x x))) three
  =   fact0 (Y fact0) three
  --&gt; (λn. if-true (is-zero n) one (mult n ((Y fact0) (pred n)))) three
  --&gt; if-true (is-zero three) one (mult three ((Y fact0) (pred three)))
  --&gt; ...
  --&gt; mult three ((Y fact0) (pred three))
  =   mult three (fact0 (Y fact0) (pred three))
  --&gt; ...
  --&gt; mult three (fact0 (Y fact0) (if-true (is-zero (pred three)) one (mult (pred three) ((Y fact0) (pred (pred three)))))
  ...
  --&gt;</code></pre>
<p>However, the <span class="math inline">\(Y\)</span> combinator is not universally applicable under any reduction strategy. Consider what happens with the <span class="math inline">\(Y\)</span> combinator, if we apply the CBV strategy.</p>
<pre><code>Y g =   (λf. (λx. f (x x)) (λx. f (x x))) g
    --&gt; (λx. g (x x)) (λx. g (x x))
    --&gt; g ((λx. g (x x)) (λx. g (x x)))
    --&gt; g (g (λx. g (x x)) (λx. g (x x)))
    --&gt; g (g (g (λx. g (x x)) (λx. g (x x))))
    --&gt; ...</code></pre>
<p>For CBV, we need the Z combinator:</p>
<pre><code>λf. (λx. f (λy. x x y)) (λx. f (λy. x x y))</code></pre>
<h4 id="let-bindings">Let bindings</h4>
<p>The last useful notation to introduce are let-bindings. We have already implemented them as part of our arithmetic expressions language – both as a substitution-based and environment-based evaluator. Let bindings can be introduced to pure lambda-calculus as <em>syntactic sugar</em> – a construct that is defined by translation to a combination of other constructs in the language. Introducing a let-binging corresponds to creating a λ-abstraction and immediately applying it to the bound expression:</p>
<pre><code>let x = e1 in e2     ≡     (λx. e2) e1</code></pre>
<p>We have to define <code>let</code> as syntactic sugar – we cannot write it as a function, the way we did for <code>if-then</code>, <code>add</code>, etc. Why is that the case?</p>
<p>We can also define a recursive version of let – called <code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span></code> in OCaml, <code class="sourceCode scheme"><span class="kw">letrec</span></code> in Scheme:</p>
<pre><code>let rec f = e1 in e2   ≡   let f = fix (λf. e1) in e2
                       ≡   (λf. e2) (fix (λf. e1))
  </code></pre>
<p>Where <code>fix</code> is an appropriate fixpoint combinator (e.g., <span class="math inline">\(Y\)</span> under CBN, <span class="math inline">\(Z\)</span> under CBV and CBN).</p>
<p>Most languages also allow specifying function arguments to the left-hand side of the equal sign:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">let</span> f x y z = e1 <span class="kw">in</span> e2</span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="kw">let</span> <span class="kw">rec</span> f x y z = e1 <span class="kw">in</span> e2</span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb65-1"><a href="#cb65-1"></a>(<span class="ex">define</span><span class="fu"> </span>(f x y z) e1)</span></code></pre></div>
<p>These can be translated as:</p>
<pre><code>let f x y z ... = e1 in e2   ≡   let f = λx y z. e1 in e2
                             ≡   (λf. e2) (λx y z. e1)</code></pre>
<h2 id="extensions">Extensions</h2>
<p>While it is useful to show how various important programming concepts and constructs can be expressed in pure lambda-calculus directly, in general, it is a rather inefficient approach.</p>
<p>The approach usually taken in designing lambda-calculus-based languages, is to take the calculus as a <em>core</em> language and add extensions to support various kinds of data.</p>
<h4 id="pairs-1">Pairs</h4>
<pre><code>&lt;Lambda&gt; ::= &lt;Variable&gt;
           | (&lt;Lambda&gt; &lt;Lambda&gt;)
           | (λ &lt;Variable&gt; . &lt;Lambda&gt;)
           | ( &lt;Lambda&gt; , &lt;Lambda&gt; )
           | fst &lt;Lambda&gt;
           | snd &lt;Lambda&gt;</code></pre>
<p>Often just written informally as an extension of a previous BNF:</p>
<pre><code>&lt;Lambda&gt; ::= ...
           | ( &lt;Lambda&gt; , &lt;Lambda&gt; )
           | fst &lt;Lambda&gt;
           | snd &lt;Lambda&gt;</code></pre>
<p>Together with the extension to syntax, we need to specify what the meaning of these new construct is. That is, we need to update the reduction strategy and provide reduction rules for the pairs. For primitive operations, these reduction rules are sometimes called <span class="math inline">\(\delta\)</span>-rules or <span class="math inline">\(\delta\)</span>-reduction rules:</p>
<pre><code>fst (l, r) --&gt;δ l
snd (l, r) --&gt;δ r</code></pre>
<!-- #### Lists -->
<h2 id="reduction-vs.-evaluation">Reduction vs. Evaluation</h2>
<h3 id="reducing-to-a-normal-form">Reducing to a Normal Form</h3>
<p>So far, in connection with Lambda calculus, we have only talked about reduction as a transformation of an expression containing redexes into another expression where the redex has been <em>reduced</em>. To actually <em>evaluate</em> a lambda-expression, we can simply iterate the reduction step (with a particular strategy), until we reach a normal form: an expression that cannot be reduced further. Note that some expressions (such as <span class="math inline">\(\Omega\)</span>) do not have a normal form – under any reduction strategy. Formally, an iteration of reduction steps <span class="math inline">\(\longrightarrow\)</span> is written as <span class="math inline">\(\longrightarrow^{*}\)</span>, which stands for “reduces in zero or more steps to”. Mathematically, it is a <em>reflexive-transitive</em> closure of <span class="math inline">\(\longrightarrow\)</span>. It is defined by the following two rules:</p>
<ol type="1">
<li><code>M --&gt;* M</code></li>
<li><code>M --&gt;* M'</code> there is a <code>N</code>, such that <code>M --&gt; N</code> and <code>N --&gt;* M'</code></li>
</ol>
<p>This can be lso expressed as:</p>
<ul>
<li>an expression reduces in zero or more steps to itself</li>
<li>an expression <span class="math inline">\(M\)</span> reduces in zero or more steps to the expression <span class="math inline">\(M&#39;\)</span>, if there is an intermediate expression <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span> reduces to <span class="math inline">\(N\)</span> and <span class="math inline">\(N\)</span> reduces in one or more steps to <span class="math inline">\(M&#39;\)</span></li>
</ul>
<p>In Haskell, this is expressed as iteration. Assuming that the one-step reduction function implementing a particular strategy has the type <code class="sourceCode haskell"><span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Lambda</span></code>, we define an iteration function as:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1"></a><span class="ot">iter ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb70-2"><a href="#cb70-2"></a>iter step e <span class="ot">=</span></span>
<span id="cb70-3"><a href="#cb70-3"></a>  <span class="kw">case</span> step e <span class="kw">of</span></span>
<span id="cb70-4"><a href="#cb70-4"></a>       <span class="dt">Just</span> e&#39; <span class="ot">-&gt;</span> iter step e&#39;</span>
<span id="cb70-5"><a href="#cb70-5"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> e</span></code></pre></div>
<p>That is, while we can perform reduction steps on an expression, we do so. If the input expression cannot be reduced (it contains no redex), just return it.</p>
<p>If we have an implementation of a reduction strategy, say, <code class="sourceCode haskell"><span class="ot">stepNormal ::</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Lambda</span></code>, then we can build a “reducer” by passing it as an argument to <code>iter</code>:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1"></a><span class="ot">iterNormal ::</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Lambda</span></span>
<span id="cb71-2"><a href="#cb71-2"></a>iterNormal <span class="ot">=</span> iter stepNormal</span></code></pre></div>
<p>We will call such a reducer an iterative evaluator, or normalizer.</p>
<h3 id="evaluation">Evaluation</h3>
<p>Instead of performing evaluation through gradual reduction (normalization) of lambda terms, we can write a recursive evaluator in the same style as we have done for our languages with arithmetic, booleans and let-bindings. This kind of evaluator takes an <em>expression</em> (term, expressing a computation) and either succeeds, returning a <em>value</em>, or fails. On the other hand, the iterative reduction function returned the same type of result as its input – an expression. The criterion for deciding when a lambda expression is reduced fully (evaluated) was that there was no further reduction possible – the expression has reached its normal form. That means, for the iterative evaluator, we didn’t have to worry about distinguishing values from expressions syntactically – once the evaluator finished reducing, we took the normal form and decided if it makes sense or not.</p>
<p>For a recursive evaluator of lambda terms, we need to decide what its return type should be. That is, we need to syntactically distinguish values from unevaluated expressions (computations). What are the values of pure lambda calculus?</p>
<p>A value is (a representation) of an entity, that has no computation left to perform and can only be inspected or used in another computation. It also does not depend on the context in which it appears – dependence on context would imply possible computation. For lambda calculus, we only have 3 syntactic forms, meaning we only have 3 candidates for what constitutes a value.</p>
<p>Application cannot be a value – it is a computation term, which can be, potentially, reduced. A single variable reference also cannot be a value – its meaning wholly depends on the context, in which it appears. The only option is lambda abstraction. In particular, an abstraction that is closed, i.e., does not contain any free variables. Having lambda-abstractions as values is consistent with Church encodings which we have explored above – each value is a closed abstraction containing only bound variables.</p>
<pre><code>  &lt;LambdaValue&gt; ::= λ &lt;Variable&gt; . &lt;Lambda&gt;   -- constructor `VLam`</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">data</span> <span class="dt">LambdaValue</span> <span class="ot">=</span> <span class="dt">VLam</span> <span class="dt">Variable</span> <span class="dt">Lambda</span></span></code></pre></div>
<p>As previously, we add values to the <code>Lambda</code> datatype:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">data</span> <span class="dt">Lambda</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Variable</span>         <span class="co">-- &lt;Lambda&gt; ::= &lt;Variable&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2"></a>            <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Variable</span> <span class="dt">Lambda</span>  <span class="co">--            | ( λ &lt;Variable&gt; . &lt;Lambda&gt; )</span></span>
<span id="cb74-3"><a href="#cb74-3"></a>            <span class="op">|</span> <span class="dt">App</span> <span class="dt">Lambda</span> <span class="dt">Lambda</span>    <span class="co">--            | ( &lt;Lambda&gt; &lt;Lambda&gt; )</span></span>
<span id="cb74-4"><a href="#cb74-4"></a>            <span class="op">|</span> <span class="dt">Val</span> <span class="dt">LambdaValue</span>      <span class="co">--            | &lt;LambdaValue&gt;</span></span></code></pre></div>
<p>Now we can implement a call-by-name evaluator for lambda terms, relying on substitution to deal with application.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1"></a><span class="ot">evalCBN ::</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">LambdaValue</span></span>
<span id="cb75-2"><a href="#cb75-2"></a>evalCBN (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="dt">Nothing</span>   <span class="co">-- all variables should be substituted</span></span>
<span id="cb75-3"><a href="#cb75-3"></a>evalCBN (<span class="dt">Val</span> v) <span class="ot">=</span> <span class="dt">Just</span> v</span>
<span id="cb75-4"><a href="#cb75-4"></a>evalCBN (<span class="dt">Lam</span> x e) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">VLam</span> x e)</span>
<span id="cb75-5"><a href="#cb75-5"></a>evalCBN (<span class="dt">App</span> e1 e2) <span class="ot">=</span> </span>
<span id="cb75-6"><a href="#cb75-6"></a>  <span class="kw">case</span> evalCBN e1 <span class="kw">of</span></span>
<span id="cb75-7"><a href="#cb75-7"></a>       <span class="dt">Just</span> (<span class="dt">VLam</span> x e) <span class="ot">-&gt;</span> evalCBN (subst x e2 e) <span class="co">-- leave argument unevaluated</span></span>
<span id="cb75-8"><a href="#cb75-8"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>For call-by-value, we use</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1"></a><span class="ot">evalCBV ::</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">LambdaValue</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>evalCBV (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb76-3"><a href="#cb76-3"></a>evalCBV (<span class="dt">Val</span> v) <span class="ot">=</span> <span class="dt">Just</span> v</span>
<span id="cb76-4"><a href="#cb76-4"></a>evalCBV (<span class="dt">Lam</span> x e) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">VLam</span> x e)</span>
<span id="cb76-5"><a href="#cb76-5"></a>evalCBV (<span class="dt">App</span> e1 e2) <span class="ot">=</span> </span>
<span id="cb76-6"><a href="#cb76-6"></a>  <span class="kw">case</span> evalCBV e1 <span class="kw">of</span></span>
<span id="cb76-7"><a href="#cb76-7"></a>       <span class="dt">Just</span> (<span class="dt">VLam</span> x e) <span class="ot">-&gt;</span> </span>
<span id="cb76-8"><a href="#cb76-8"></a>         <span class="kw">case</span> evalCBV e2 <span class="kw">of</span>    <span class="co">-- evaluate the argument before substituting</span></span>
<span id="cb76-9"><a href="#cb76-9"></a>              <span class="dt">Just</span> v2 <span class="ot">-&gt;</span> evalCBV (subst x (<span class="dt">Val</span> v2) e)</span>
<span id="cb76-10"><a href="#cb76-10"></a>              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb76-11"><a href="#cb76-11"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>What is the benefit of a recursive evaluator vs. reduction-based iterative evaluator?</p>
<h3 id="environment-based-evaluation">Environment-based Evaluation</h3>
<p>We can also use environments to implement a recursive evaluator for lambda calculus. Here is a basic implementation of a call-by-value one.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1"></a><span class="ot">evalCBV ::</span> <span class="dt">Env</span> <span class="dt">LambdaValue</span> <span class="ot">-&gt;</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">LambdaValue</span></span>
<span id="cb77-2"><a href="#cb77-2"></a>evalCBV env (<span class="dt">Val</span> v) <span class="ot">=</span> <span class="dt">Just</span> v</span>
<span id="cb77-3"><a href="#cb77-3"></a>evalCBV env (<span class="dt">Var</span> x) <span class="ot">=</span> get x env</span>
<span id="cb77-4"><a href="#cb77-4"></a>evalCBV env (<span class="dt">Lam</span> x e) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">VLam</span> x e)</span>
<span id="cb77-5"><a href="#cb77-5"></a>evalCBV env (<span class="dt">App</span> e1 e2) <span class="ot">=</span> </span>
<span id="cb77-6"><a href="#cb77-6"></a>  <span class="kw">case</span> evalCBV env e1 <span class="kw">of</span></span>
<span id="cb77-7"><a href="#cb77-7"></a>       <span class="dt">Just</span> (<span class="dt">VLam</span> x e) <span class="ot">-&gt;</span></span>
<span id="cb77-8"><a href="#cb77-8"></a>         <span class="kw">case</span> evalCBV env e2 <span class="kw">of</span></span>
<span id="cb77-9"><a href="#cb77-9"></a>              <span class="dt">Just</span> v2 <span class="ot">-&gt;</span> evalCBV (add x v2 env) e  <span class="co">-- bind the abstracted variable to the argument&#39;s value</span></span>
<span id="cb77-10"><a href="#cb77-10"></a>              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb77-11"><a href="#cb77-11"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<h3 id="scoping">Scoping</h3>
<p>Our evaluator might seem ok at first sight. However, there is a problem.</p>
<p>Using our intuition from Haskell (and Racket), what shall we expect to be the value resulting from the expression below?</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb78-1"><a href="#cb78-1"></a><span class="kw">let</span> x = <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="kw">let</span> f y = y + x <span class="kw">in</span></span>
<span id="cb78-3"><a href="#cb78-3"></a><span class="kw">let</span> x = <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb78-4"><a href="#cb78-4"></a>f <span class="dv">1</span></span></code></pre></div>
<p>In Haskell, this expression evaluates to <code class="sourceCode haskell"><span class="dv">3</span></code>.</p>
<p>Using our desugaring rule introduced earlier, this expands to the pure lambda calculus expression</p>
<pre><code>(λx. (λf. (λx. f 1) 3) (λy. (+ y x))) 2</code></pre>
<p>In Haskell, this is represented as (for a lambda extended with numbers and addition as primitives):</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1"></a>e <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span>                                        <span class="co">-- let x = 2 in</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>          (<span class="dt">App</span> (<span class="dt">Lam</span> <span class="st">&quot;f&quot;</span>                                 <span class="co">-- let f = ... in</span></span>
<span id="cb80-3"><a href="#cb80-3"></a>                  (<span class="dt">App</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span>                         <span class="co">-- let x = 3 in</span></span>
<span id="cb80-4"><a href="#cb80-4"></a>                         (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Val</span> (<span class="dt">Num</span> <span class="dv">1</span>)))) <span class="co">-- f 1</span></span>
<span id="cb80-5"><a href="#cb80-5"></a>                       (<span class="dt">Val</span> (<span class="dt">Num</span> <span class="dv">3</span>))))</span>
<span id="cb80-6"><a href="#cb80-6"></a>               (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> ((<span class="dt">Add</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))))))</span>
<span id="cb80-7"><a href="#cb80-7"></a>        (<span class="dt">Val</span> (<span class="dt">Num</span> <span class="dv">2</span>))</span></code></pre></div>
<p>What happens if we ask our evaluator to evaluate the above expression?</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1"></a><span class="op">&gt;</span> evalCBV empty e</span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="dt">Just</span> (<span class="dt">Num</span> <span class="dv">4</span>) </span></code></pre></div>
<p>What we implemented here is dynamic scoping. The value of a variable is determined by the most recently bound variable at runtime. In general, under dynamic scoping the value of a variable cannot be determined statically, that is, just by looking at the code. This is usually counterintuitive for us. We are used to <em>lexical</em> (or <em>static</em>) scoping, that is, the scope of a variable is given by its location in the source code of the program. Most programming language use lexical scoping, because this allows us to easily reason about the values of variables when we read source code. Examples of languages with dynamic scoping are: Lisp (Emacs), LaTeX, bash. Some languages allow choosing scope when defining a variables, such as Common Lisp or Perl. How do we ensure static scoping?</p>
<h3 id="closures">Closures</h3>
<ul>
<li>The problem arises because we are passing around a lambda value and the original association between its free variables and values is lost</li>
<li>We need a way to keep this association: <em>closures</em></li>
</ul>
<p>Closures package up a lambda abstraction with the environment that was valid at the time of evaluating the abstraction. They can be implemented simply as a pairing of a lambda abstraction with an environment:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1"></a><span class="kw">data</span> <span class="dt">LambdaValue</span> <span class="ot">=</span> <span class="dt">Clo</span> <span class="dt">Variable</span> <span class="dt">Lambda</span> (<span class="dt">Env</span> <span class="dt">LambdaValue</span>)</span>
<span id="cb82-2"><a href="#cb82-2"></a></span>
<span id="cb82-3"><a href="#cb82-3"></a><span class="kw">data</span> <span class="dt">Lambda</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Variable</span></span>
<span id="cb82-4"><a href="#cb82-4"></a>            <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Variable</span> <span class="dt">Lambda</span></span>
<span id="cb82-5"><a href="#cb82-5"></a>            <span class="op">|</span> <span class="dt">App</span> <span class="dt">Lambda</span> <span class="dt">Lambda</span></span>
<span id="cb82-6"><a href="#cb82-6"></a>            <span class="op">|</span> <span class="dt">Val</span> <span class="dt">LambdaValue</span></span>
<span id="cb82-7"><a href="#cb82-7"></a></span>
<span id="cb82-8"><a href="#cb82-8"></a><span class="ot">evalCBV ::</span> <span class="dt">Env</span> <span class="dt">LambdaValue</span> <span class="ot">-&gt;</span> <span class="dt">Lambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">LambdaValue</span></span>
<span id="cb82-9"><a href="#cb82-9"></a>evalCBV env (<span class="dt">Var</span> x) <span class="ot">=</span> get x env</span>
<span id="cb82-10"><a href="#cb82-10"></a>evalCBV env (<span class="dt">Val</span> v) <span class="ot">=</span> <span class="dt">Just</span> v</span>
<span id="cb82-11"><a href="#cb82-11"></a>evalCBV env (<span class="dt">Lam</span> x e) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Clo</span> x e env) <span class="co">-- save the current environment</span></span>
<span id="cb82-12"><a href="#cb82-12"></a>evalCBV env (<span class="dt">App</span> e1 e2) <span class="ot">=</span> </span>
<span id="cb82-13"><a href="#cb82-13"></a>  <span class="kw">case</span> evalCBV env e1 <span class="kw">of</span></span>
<span id="cb82-14"><a href="#cb82-14"></a>       <span class="dt">Just</span> (<span class="dt">Clo</span> x e env&#39;) <span class="ot">-&gt;</span>              <span class="co">-- the closure remembers the corresponding environment</span></span>
<span id="cb82-15"><a href="#cb82-15"></a>         <span class="kw">case</span> evalCBV env e2 <span class="kw">of</span></span>
<span id="cb82-16"><a href="#cb82-16"></a>              <span class="dt">Just</span> v2 <span class="ot">-&gt;</span> evalCBV (add x v2 env&#39;) e  <span class="co">-- evaluate in the closure&#39;s environment updated with the argument binding </span></span>
<span id="cb82-17"><a href="#cb82-17"></a>              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb82-18"><a href="#cb82-18"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Now all abstraction bodies are evaluated with the environment that belongs to them <em>statically</em>. And, indeed, the example expression evaluates as expected:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1"></a><span class="op">&gt;</span> evalCBV empty e</span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="dt">Just</span> (<span class="dt">Num</span> <span class="dv">3</span>)</span></code></pre></div>
<!-- How about call by name and environments? -->
<h2 id="de-bruijn-indices">De Bruijn Indices</h2>
<p>As we have talked about before, the name of a bound variable is insignificant – as long as there is a consistency between the binder and the variable reference. This is called alpha-equivalence. Using strings as variables seems natural: it corresponds to the mathematical with variable names. However, as a computer representation this is inefficient: there are infinitely many ways to represent any lambda term: <code>λx. x</code>, <code>λy. y</code>, <code>λz. z</code>, <code>λzzzz. zzzz</code>, <code>λlongervariablename. longervariablename</code>, …</p>
<p>Moreover representing variable names as strings forces us to complicate the definition of substitution and define functions for obtaining fresh variable names. In an implementation, we would ideally want to do away with these complications. Sure, we could simply use natural numbers to represent variables and this would simplify picking a fresh variable name – e.g., by taking the maximum of all free variables and adding 1. We sill complicate the substitution definition and we still have the problem of multiple representations of alpha-equivalent lambda terms. There is another alternative.</p>
<p>When we look at a lambda abstraction:</p>
<p><span class="math display">\[
\lambda x.\ (\lambda y.\ x\ y\ (\lambda x.\ \lambda z.\ x\ z\ y))
\]</span></p>
<p>we really use the occurrence of <span class="math inline">\(x\)</span> in the binder as a <em>marker</em> and a variable reference as a reference back to the marker, that is, each variable can be viewed as referring back to the binder that bound it:</p>
<pre><code>      +-------------------+
      |                   |
      +----+   +------+   |
      |    |   |      |   |
λx. (λy. x y (λx. λz. x z y))
 |       |         |    |
 +-------+         +----+</code></pre>
<p>This means that we do not really need to use names to know where an argument value should be inserted:</p>
<pre><code>      +-------------------+
      |                   |
      +----+   +------+   |
      |    |   |      |   |
λ_. (λ_. * * (λ_. λ_. * * *))
 |       |         |    |
 +-------+         +----+</code></pre>
<p>Now the question is, how do we represent these connections without using names. The Dutch mathematician <a href="https://en.wikipedia.org/wiki/Nicolaas_Govert_de_Bruijn">Nicolaas Govert de Bruijn</a> had the idea that each variable reference should represent the number of binders between it and the binder that bound it. If there is no other binder between the reference and its binder, the count 0 and we can refer to the binder by that number. If there is one binder between, we refer to the variable’s binder by 1, etc.</p>
<pre><code>      +-------------------+
      |                   |
      +----+   +------+   |
      |    |   |      |   |
λ_. (λ_. 1 0 (λ_. λ_. 1 0 2))
 |       |         |    |
 +-------+         +----+</code></pre>
<p>This leads to a simplification of the syntax: since we use do not need to mark binders using variables, lambdas do not carry any variable names:</p>
<pre><code>    +-----------------+
    |                 |
    +----+  +-----+   |
    |    |  |     |   |
λ. (λ. 1 0 (λ. λ. 1 0 2))
|      |       |    |
+------+       +----+</code></pre>
<p>Thus the syntax of Lambda expressions using de Bruijn indices is as follows:</p>
<pre><code>&lt;DLambda&gt; ::= &lt;Index&gt;                -- variable reference
            | &lt;DLambda&gt; &lt;DLambda&gt;    -- application is as before
            | λ. &lt;DLambda&gt;           -- lambda abstraction does refer to the bound variable explicitly</code></pre>
<p>Haskell:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1"></a><span class="kw">data</span> <span class="dt">DLambda</span> <span class="ot">=</span> <span class="dt">DVar</span> <span class="dt">Integer</span></span>
<span id="cb89-2"><a href="#cb89-2"></a>             <span class="op">|</span> <span class="dt">DApp</span> <span class="dt">DLambda</span> <span class="dt">DLambda</span></span>
<span id="cb89-3"><a href="#cb89-3"></a>             <span class="op">|</span> <span class="dt">DLam</span> <span class="dt">DLambda</span></span></code></pre></div>
<p>Here are a few more examples:</p>
<ul>
<li>Any identity function (<code>λx. x</code>, <code>λy. y</code>, …) is <code>λ. 0</code></li>
<li><code>λx. x x</code> is <code>λ. 0 0</code></li>
<li>Churchian for true and false is <code>λ. λ. 1</code> and <code>λ. λ. 0</code>, respectively</li>
<li>Church numerals are <code>λ. λ. 0</code>, <code>λ. λ. 1 0</code>, <code>λ. λ. 1 (1 0)</code>, <code>λ. λ. 1 (1 (1 0))</code></li>
<li>The Y combinator, <code>λf. (λx. f (x x)) (λx. f (x x))</code> is <code>λ. (λ. 1 (0 0)) (λ. 1 (0 0))</code></li>
</ul>
<p>What is the advantage of using de Bruijn indices? It certainly isn’t (human) readability. Maybe you have noticed, that for each alpha-equivalent term, there is only one representation. This is a major advantage when implementing lambda calculus, since we do not need to care about renaming of bound variables. Another advantage is that “environments” for evaluating lambda expressions are simplified – they are just stacks of values:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1"></a><span class="kw">data</span> <span class="dt">DValue</span> <span class="ot">=</span> <span class="dt">DClo</span> <span class="dt">DLambda</span> [<span class="dt">DValue</span>]</span>
<span id="cb90-2"><a href="#cb90-2"></a></span>
<span id="cb90-3"><a href="#cb90-3"></a><span class="ot">eval ::</span> [<span class="dt">DValue</span>] <span class="ot">-&gt;</span> <span class="dt">DLambda</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">DValue</span></span>
<span id="cb90-4"><a href="#cb90-4"></a>eval env (<span class="dt">DVar</span> i) <span class="op">|</span> i <span class="op">&lt;</span> <span class="fu">length</span> env <span class="ot">=</span> <span class="dt">Just</span> (env<span class="op">!!</span>i)   <span class="co">-- lookup the value</span></span>
<span id="cb90-5"><a href="#cb90-5"></a>                  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb90-6"><a href="#cb90-6"></a>eval env (<span class="dt">DApp</span> e1 e2) <span class="ot">=</span> </span>
<span id="cb90-7"><a href="#cb90-7"></a>  <span class="kw">case</span> eval env e1 <span class="kw">of</span></span>
<span id="cb90-8"><a href="#cb90-8"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb90-9"><a href="#cb90-9"></a>       <span class="dt">Just</span> (<span class="dt">DClo</span> e env&#39;) <span class="ot">-&gt;</span> <span class="kw">case</span> eval env e2 <span class="kw">of</span></span>
<span id="cb90-10"><a href="#cb90-10"></a>                                  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb90-11"><a href="#cb90-11"></a>                                  <span class="dt">Just</span> v2 <span class="ot">-&gt;</span> eval (v2 <span class="op">:</span> env&#39;) e</span>
<span id="cb90-12"><a href="#cb90-12"></a>eval env (<span class="dt">DLam</span> e) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">DClo</span> e env)</span></code></pre></div>
<h1 id="imperative-features-programming-with-state">Imperative Features: Programming with State</h1>
<p>The language features we have considered so far were <em>pure</em> in the sense that their evaluation didn’t yield any side-effect.[^Well, there was one possible side-effect: failure.]</p>
<p>Now we will look at features associated with <em>imperative</em> languages. In an imperative language computation proceeds by processing <em>statements</em> (or <em>commands</em>) which explicitly modify the machine state. These changes in state can me modifying memory, consuming input, producing output, etc.</p>
<h2 id="imperative-variables-i">Imperative Variables I</h2>
<p>The first side-effect that we introduce is modifying memory via imperative variables. How do these differ from applicative variables? Probably the simplest way to think about the difference is that applicative variables bind to (stand for) values, imperative variables stand for memory cells. How do we model them?</p>
<p>The simplest approach: modelling memory – the <em>store</em> – as a mapping between variables and values, like we did with environments. The difference is in how we use them. While environments were used as read-only entities – the evaluator (at each stage) would receive an environment and might perform recursive calls with a modified environment, but it could pass a modified environment back to its context. A store, on the other hand, is treated as a read and write entity. At each stage, the evaluator can not just read what is stored in a variable, but also modify and return an updated store.</p>
<p>We will demonstrate using a small imperative language with basic arithmetic, assignment and retrieval of variables. To compose statements, we introduce a sequencing command: <code>Seq s1 s2</code> first executes statement <code>s1</code> and then <code>s2</code>. Notice how the execution of <code>s2</code> uses an updated store produced by the execution of <code>s1</code>. Note that our expressions are still pure: they can read from the store, but not update it. This is apparent from the type of the expression evaluator <code class="sourceCode haskell"><span class="ot">evalExpr ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></code>. Contrast this with the type of the evaluator for statements:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> <span class="ot">=</span> <span class="dt">Assign</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb91-2"><a href="#cb91-2"></a>          <span class="op">|</span> <span class="dt">Seq</span> <span class="dt">Stmt</span> <span class="dt">Stmt</span></span>
<span id="cb91-3"><a href="#cb91-3"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb91-4"><a href="#cb91-4"></a></span>
<span id="cb91-5"><a href="#cb91-5"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Value</span></span>
<span id="cb91-6"><a href="#cb91-6"></a>          <span class="op">|</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb91-7"><a href="#cb91-7"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb91-8"><a href="#cb91-8"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb91-9"><a href="#cb91-9"></a></span>
<span id="cb91-10"><a href="#cb91-10"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">Num</span> <span class="dt">Integer</span></span>
<span id="cb91-11"><a href="#cb91-11"></a>           <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb91-12"><a href="#cb91-12"></a></span>
<span id="cb91-13"><a href="#cb91-13"></a><span class="kw">type</span> <span class="dt">Store</span> <span class="ot">=</span> <span class="dt">Env</span> <span class="dt">Value</span></span>
<span id="cb91-14"><a href="#cb91-14"></a></span>
<span id="cb91-15"><a href="#cb91-15"></a><span class="ot">evalExpr ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb91-16"><a href="#cb91-16"></a>evalExpr sto (<span class="dt">Val</span> v) <span class="ot">=</span> <span class="dt">Just</span> v</span>
<span id="cb91-17"><a href="#cb91-17"></a>evalExpr sto (<span class="dt">Var</span> x) <span class="ot">=</span> get x sto</span>
<span id="cb91-18"><a href="#cb91-18"></a>evalExpr sto (<span class="dt">Add</span> e1 e2) <span class="ot">=</span></span>
<span id="cb91-19"><a href="#cb91-19"></a>  <span class="kw">case</span> evalExpr sto e1 <span class="kw">of</span></span>
<span id="cb91-20"><a href="#cb91-20"></a>       <span class="dt">Just</span> (<span class="dt">Num</span> n1) <span class="ot">-&gt;</span> <span class="kw">case</span> evalExpr sto e2 <span class="kw">of</span></span>
<span id="cb91-21"><a href="#cb91-21"></a>                             <span class="dt">Just</span> (<span class="dt">Num</span> n2) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Num</span> (n1 <span class="op">+</span> n2))</span>
<span id="cb91-22"><a href="#cb91-22"></a>                             _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb91-23"><a href="#cb91-23"></a>       _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb91-24"><a href="#cb91-24"></a></span>
<span id="cb91-25"><a href="#cb91-25"></a><span class="ot">execStmt ::</span> (<span class="dt">Store</span>, <span class="dt">Stmt</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Store</span></span>
<span id="cb91-26"><a href="#cb91-26"></a>execStmt (sto, <span class="dt">Assign</span> x e) <span class="ot">=</span> </span>
<span id="cb91-27"><a href="#cb91-27"></a>  <span class="kw">case</span> evalExpr sto e <span class="kw">of</span></span>
<span id="cb91-28"><a href="#cb91-28"></a>       <span class="dt">Just</span> v <span class="ot">-&gt;</span> <span class="dt">Just</span> (add x v sto)</span>
<span id="cb91-29"><a href="#cb91-29"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb91-30"><a href="#cb91-30"></a>execStmt (sto, <span class="dt">Seq</span> c1 c2) <span class="ot">=</span> </span>
<span id="cb91-31"><a href="#cb91-31"></a>  <span class="kw">case</span> execStmt (sto, c1) <span class="kw">of</span></span>
<span id="cb91-32"><a href="#cb91-32"></a>       <span class="dt">Just</span> sto&#39; <span class="ot">-&gt;</span> execStmt (sto&#39;, c2)</span>
<span id="cb91-33"><a href="#cb91-33"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Note, how the function <code class="sourceCode haskell">execStmt</code> does not return any value – the result of the computation is determined purely by the effect it had on the store.</p>
<h2 id="printing-and-output-streams">Printing and Output Streams</h2>
<p>We model output streams using a list of values.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb92-2"><a href="#cb92-2"></a>          <span class="op">|</span> <span class="dt">Print</span> <span class="dt">Expr</span></span>
<span id="cb92-3"><a href="#cb92-3"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb92-4"><a href="#cb92-4"></a></span>
<span id="cb92-5"><a href="#cb92-5"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="op">...</span>  <span class="co">-- same as before</span></span>
<span id="cb92-6"><a href="#cb92-6"></a></span>
<span id="cb92-7"><a href="#cb92-7"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span> <span class="co">-- as before</span></span>
<span id="cb92-8"><a href="#cb92-8"></a></span>
<span id="cb92-9"><a href="#cb92-9"></a><span class="kw">type</span> <span class="dt">Store</span> <span class="ot">=</span> <span class="op">...</span> <span class="co">-- as before</span></span>
<span id="cb92-10"><a href="#cb92-10"></a></span>
<span id="cb92-11"><a href="#cb92-11"></a><span class="kw">type</span> <span class="dt">Out</span> <span class="ot">=</span> [<span class="dt">Value</span>]</span>
<span id="cb92-12"><a href="#cb92-12"></a></span>
<span id="cb92-13"><a href="#cb92-13"></a><span class="ot">evalExpr ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb92-14"><a href="#cb92-14"></a>evalExpr sto (<span class="dt">Val</span> v) <span class="ot">=</span> <span class="op">...</span> <span class="co">-- all cases as before</span></span>
<span id="cb92-15"><a href="#cb92-15"></a></span>
<span id="cb92-16"><a href="#cb92-16"></a><span class="co">-- We need to handle the output stream. Notice the cases for Seq and Print</span></span>
<span id="cb92-17"><a href="#cb92-17"></a><span class="ot">execStmt ::</span> (<span class="dt">Store</span>, <span class="dt">Stmt</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Store</span>, <span class="dt">Out</span>)</span>
<span id="cb92-18"><a href="#cb92-18"></a>execStmt (sto, <span class="dt">Assign</span> x e) <span class="ot">=</span> </span>
<span id="cb92-19"><a href="#cb92-19"></a>  <span class="kw">case</span> evalExpr sto e <span class="kw">of</span></span>
<span id="cb92-20"><a href="#cb92-20"></a>       <span class="dt">Just</span> v <span class="ot">-&gt;</span> <span class="dt">Just</span> (add x v sto, [])</span>
<span id="cb92-21"><a href="#cb92-21"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb92-22"><a href="#cb92-22"></a>execStmt (sto, <span class="dt">Seq</span> c1 c2) <span class="ot">=</span> </span>
<span id="cb92-23"><a href="#cb92-23"></a>  <span class="kw">case</span> execStmt (sto, c1) <span class="kw">of</span></span>
<span id="cb92-24"><a href="#cb92-24"></a>       <span class="dt">Just</span> (sto&#39;, out1) <span class="ot">-&gt;</span> </span>
<span id="cb92-25"><a href="#cb92-25"></a>         <span class="kw">case</span> execStmt (sto&#39;, c2) <span class="kw">of</span></span>
<span id="cb92-26"><a href="#cb92-26"></a>              <span class="dt">Just</span> (sto&#39;&#39;, out2) <span class="ot">-&gt;</span> <span class="dt">Just</span> (sto&#39;&#39;, out1 <span class="op">++</span> out2)</span>
<span id="cb92-27"><a href="#cb92-27"></a>              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb92-28"><a href="#cb92-28"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb92-29"><a href="#cb92-29"></a>execStmt (sto, <span class="dt">Print</span> e) <span class="ot">=</span></span>
<span id="cb92-30"><a href="#cb92-30"></a>  <span class="kw">case</span> evalExpr sto e <span class="kw">of</span></span>
<span id="cb92-31"><a href="#cb92-31"></a>       <span class="dt">Just</span> v <span class="ot">-&gt;</span> <span class="dt">Just</span> (sto, [v])</span>
<span id="cb92-32"><a href="#cb92-32"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<h2 id="loops">Loops</h2>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> <span class="ot">=</span> <span class="op">...</span> </span>
<span id="cb93-2"><a href="#cb93-2"></a>          <span class="op">|</span> <span class="dt">While</span> <span class="dt">Expr</span> <span class="dt">Stmt</span></span>
<span id="cb93-3"><a href="#cb93-3"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb93-4"><a href="#cb93-4"></a></span>
<span id="cb93-5"><a href="#cb93-5"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="op">...</span> </span>
<span id="cb93-6"><a href="#cb93-6"></a>          <span class="op">|</span> <span class="dt">Le</span> <span class="dt">Expr</span> <span class="dt">Expr</span>  <span class="co">-- adding a boolean operation</span></span>
<span id="cb93-7"><a href="#cb93-7"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb93-8"><a href="#cb93-8"></a></span>
<span id="cb93-9"><a href="#cb93-9"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb93-10"><a href="#cb93-10"></a>           <span class="op">|</span> <span class="dt">Bool</span> <span class="dt">Bool</span>    <span class="co">-- booleans to be used in the condition expression</span></span>
<span id="cb93-11"><a href="#cb93-11"></a>           <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb93-12"><a href="#cb93-12"></a></span>
<span id="cb93-13"><a href="#cb93-13"></a><span class="kw">type</span> <span class="dt">Store</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Value</span></span>
<span id="cb93-14"><a href="#cb93-14"></a></span>
<span id="cb93-15"><a href="#cb93-15"></a><span class="kw">type</span> <span class="dt">Out</span> <span class="ot">=</span> [<span class="dt">Value</span>]</span>
<span id="cb93-16"><a href="#cb93-16"></a></span>
<span id="cb93-17"><a href="#cb93-17"></a><span class="ot">evalExpr ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb93-18"><a href="#cb93-18"></a><span class="op">...</span></span>
<span id="cb93-19"><a href="#cb93-19"></a>evalExpr sto (<span class="dt">Le</span> e1 e2) <span class="ot">=</span></span>
<span id="cb93-20"><a href="#cb93-20"></a>  <span class="kw">case</span> evalExpr sto e1 <span class="kw">of</span></span>
<span id="cb93-21"><a href="#cb93-21"></a>       <span class="dt">Just</span> (<span class="dt">Num</span> n1) <span class="ot">-&gt;</span> <span class="kw">case</span> evalExpr sto e2 <span class="kw">of</span></span>
<span id="cb93-22"><a href="#cb93-22"></a>                             <span class="dt">Just</span> (<span class="dt">Num</span> n2) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Bool</span> (n1 <span class="op">&lt;=</span> n2))</span>
<span id="cb93-23"><a href="#cb93-23"></a>                             _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb93-24"><a href="#cb93-24"></a>       _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb93-25"><a href="#cb93-25"></a></span>
<span id="cb93-26"><a href="#cb93-26"></a><span class="ot">execStmt ::</span> (<span class="dt">Store</span>, <span class="dt">Stmt</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Store</span>, <span class="dt">Out</span>)</span>
<span id="cb93-27"><a href="#cb93-27"></a><span class="op">...</span></span>
<span id="cb93-28"><a href="#cb93-28"></a>execStmt (sto, <span class="dt">While</span> e c) <span class="ot">=</span></span>
<span id="cb93-29"><a href="#cb93-29"></a>  <span class="kw">case</span> evalExpr sto e <span class="kw">of</span></span>
<span id="cb93-30"><a href="#cb93-30"></a>       <span class="dt">Just</span> (<span class="dt">Bool</span> <span class="dt">False</span>) <span class="ot">-&gt;</span> <span class="dt">Just</span> (sto, [])</span>
<span id="cb93-31"><a href="#cb93-31"></a>       <span class="dt">Just</span> (<span class="dt">Bool</span> <span class="dt">True</span>) <span class="ot">-&gt;</span> </span>
<span id="cb93-32"><a href="#cb93-32"></a>         <span class="kw">case</span> execStmt (sto, c) <span class="kw">of</span></span>
<span id="cb93-33"><a href="#cb93-33"></a>              <span class="dt">Just</span> (sto&#39;, out1) <span class="ot">-&gt;</span></span>
<span id="cb93-34"><a href="#cb93-34"></a>                <span class="kw">case</span> execStmt (sto&#39;, <span class="dt">While</span> e c) <span class="kw">of</span></span>
<span id="cb93-35"><a href="#cb93-35"></a>                     <span class="dt">Just</span> (sto&#39;&#39;, out2) <span class="ot">-&gt;</span> <span class="dt">Just</span> (sto&#39;&#39;, out1 <span class="op">++</span> out2)</span>
<span id="cb93-36"><a href="#cb93-36"></a>                     _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb93-37"><a href="#cb93-37"></a>              _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb93-38"><a href="#cb93-38"></a>       _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<h2 id="imperative-variables-ii-block-scope">Imperative Variables II: Block Scope</h2>
<ul>
<li><p>Our first representation of memory was a direct mapping from names to stored values</p></li>
<li><p>Consequence:</p>
<ul>
<li>A variable defined inside, e.g., a while loop or a branch of an if statement, is visible and accessible outside of that loop, or branch</li>
</ul></li>
<li><p>This is does not correspond to what happens in most common imperative languages</p></li>
<li><p>Languages like Python, C, Java, … enforce <em>block scope</em>, that is a variable is only visible in the block in which it was defined (or declared)</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb94-1"><a href="#cb94-1"></a><span class="dt">int</span> x = <span class="dv">20</span>;</span>
<span id="cb94-2"><a href="#cb94-2"></a></span>
<span id="cb94-3"><a href="#cb94-3"></a><span class="kw">do</span> {</span>
<span id="cb94-4"><a href="#cb94-4"></a>  <span class="dt">int</span> x = <span class="dv">10</span>; <span class="co">// different variable - different storage cell</span></span>
<span id="cb94-5"><a href="#cb94-5"></a>              <span class="co">// inside this block, shadows the outer x</span></span>
<span id="cb94-6"><a href="#cb94-6"></a>  <span class="dt">int</span> y = <span class="dv">1</span>;</span>
<span id="cb94-7"><a href="#cb94-7"></a>} <span class="kw">while</span> (<span class="kw">false</span>);</span>
<span id="cb94-8"><a href="#cb94-8"></a></span>
<span id="cb94-9"><a href="#cb94-9"></a><span class="co">// here, x is still 20</span></span>
<span id="cb94-10"><a href="#cb94-10"></a><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(y); <span class="co">// error: y doesn&#39;t exist here</span></span></code></pre></div></li>
<li><p>Block scope is similar to let expressions</p></li>
<li><p>Another issue: in languages like Python, or Java (for object types), the semantics of assignment is to set a reference – instead of copying the object stored in the memory location</p></li>
<li><p>E.g., the Python program</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1"></a>x <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb95-2"><a href="#cb95-2"></a>y <span class="op">=</span> x</span>
<span id="cb95-3"><a href="#cb95-3"></a><span class="bu">print</span>(y)</span>
<span id="cb95-4"><a href="#cb95-4"></a>y.append(<span class="dv">4</span>)</span>
<span id="cb95-5"><a href="#cb95-5"></a><span class="bu">print</span>(x)</span></code></pre></div>
<p>prints</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1"></a>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb96-2"><a href="#cb96-2"></a>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span></code></pre></div>
<p>because <code>x</code> and <code>y</code> refer to the same object</p></li>
</ul>
<!-- - How do we represent references/pointers? -->
<p>How do we combine block scope with imperative variables?</p>
<ul>
<li><p>Block is captured well by (read-only) environments</p></li>
<li><p>A store captures variables which can be modified</p></li>
<li><p>Idea:</p>
<ul>
<li><p>Environment for mapping variables to “addresses”</p></li>
<li><p>Store for mapping addresses to (maybe) values</p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">type</span> <span class="dt">Address</span> <span class="ot">=</span> <span class="dt">Integer</span></span>
<span id="cb97-2"><a href="#cb97-2"></a></span>
<span id="cb97-3"><a href="#cb97-3"></a><span class="kw">type</span> <span class="dt">Store</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Integer</span> <span class="dt">Value</span></span>
<span id="cb97-4"><a href="#cb97-4"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span></span></code></pre></div>
<p>Implementation: we add a new construct <code class="sourceCode haskell"><span class="dt">Block</span></code> which bundles variable <em>declarations</em> with statements that can use these variables. We keep our <code>Assign</code> construct, however, we’ll redefine its meaning (implementation). We will also change the semantics of variable references (<code class="sourceCode haskell"><span class="dt">Var</span></code>)</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> <span class="ot">=</span> <span class="dt">Assign</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="co">-- we&#39;re keeping our assignment statement</span></span>
<span id="cb98-2"><a href="#cb98-2"></a>          <span class="op">...</span></span>
<span id="cb98-3"><a href="#cb98-3"></a>          <span class="op">|</span> <span class="dt">Block</span> <span class="dt">Decl</span> <span class="dt">Stmt</span>    <span class="co">-- a block is a bunch of variable declarations followed by statements</span></span>
<span id="cb98-4"><a href="#cb98-4"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb98-5"><a href="#cb98-5"></a></span>
<span id="cb98-6"><a href="#cb98-6"></a><span class="kw">data</span> <span class="dt">Decl</span> <span class="ot">=</span> <span class="dt">NewVar</span> <span class="dt">String</span> <span class="dt">Decl</span> <span class="co">-- a declaration list can be</span></span>
<span id="cb98-7"><a href="#cb98-7"></a>          <span class="op">|</span> <span class="dt">Empty</span>              <span class="co">-- empty</span></span>
<span id="cb98-8"><a href="#cb98-8"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb98-9"><a href="#cb98-9"></a></span>
<span id="cb98-10"><a href="#cb98-10"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="op">...</span>                <span class="co">-- expressions remain the same...</span></span>
<span id="cb98-11"><a href="#cb98-11"></a>          <span class="op">|</span> <span class="dt">Var</span> x              <span class="co">-- except we will change the meaning of variable lookup</span></span>
<span id="cb98-12"><a href="#cb98-12"></a>          <span class="op">|</span> <span class="op">...</span>               </span>
<span id="cb98-13"><a href="#cb98-13"></a></span>
<span id="cb98-14"><a href="#cb98-14"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">Num</span> <span class="dt">Integer</span>       <span class="co">-- value are the same</span></span>
<span id="cb98-15"><a href="#cb98-15"></a>           <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb98-16"><a href="#cb98-16"></a></span>
<span id="cb98-17"><a href="#cb98-17"></a><span class="kw">type</span> <span class="dt">Out</span> <span class="ot">=</span> [<span class="dt">Value</span>]</span>
<span id="cb98-18"><a href="#cb98-18"></a></span>
<span id="cb98-19"><a href="#cb98-19"></a></span>
<span id="cb98-20"><a href="#cb98-20"></a><span class="co">-- There are multiple ways we can represent allocation</span></span>
<span id="cb98-21"><a href="#cb98-21"></a><span class="co">-- The questions to answer are:</span></span>
<span id="cb98-22"><a href="#cb98-22"></a><span class="co">--   a) how do we select the next address?</span></span>
<span id="cb98-23"><a href="#cb98-23"></a><span class="co">--   b) what do we store at the freshly allocated address?</span></span>
<span id="cb98-24"><a href="#cb98-24"></a><span class="co">-- Here we use the following:</span></span>
<span id="cb98-25"><a href="#cb98-25"></a><span class="co">--   a) We take the highest address plus one</span></span>
<span id="cb98-26"><a href="#cb98-26"></a><span class="co">--   b) We store the number 0. Note that this choice can have various consequences: Do we need to distinguish between initialized and unitialized storage cells?</span></span>
<span id="cb98-27"><a href="#cb98-27"></a></span>
<span id="cb98-28"><a href="#cb98-28"></a><span class="ot">alloc ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> (<span class="dt">Address</span>, <span class="dt">Store</span>)</span>
<span id="cb98-29"><a href="#cb98-29"></a>alloc [] <span class="ot">=</span> (first, add first (<span class="dt">Num</span> <span class="dv">0</span>) empty)</span>
<span id="cb98-30"><a href="#cb98-30"></a>  <span class="kw">where</span> first <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb98-31"><a href="#cb98-31"></a>alloc m <span class="ot">=</span> (new, add new (<span class="dt">Num</span> <span class="dv">0</span>) m)</span>
<span id="cb98-32"><a href="#cb98-32"></a>  <span class="kw">where</span> new <span class="ot">=</span> (<span class="fu">maximum</span> (keys m)) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb98-33"><a href="#cb98-33"></a>        keys [] <span class="ot">=</span> [] <span class="co">-- get all the keys from a map</span></span>
<span id="cb98-34"><a href="#cb98-34"></a>        keys ((k, _) <span class="op">:</span> m) <span class="ot">=</span> k <span class="op">:</span> keys m</span>
<span id="cb98-35"><a href="#cb98-35"></a></span>
<span id="cb98-36"><a href="#cb98-36"></a><span class="co">-- process declarations</span></span>
<span id="cb98-37"><a href="#cb98-37"></a><span class="ot">procDecl ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Decl</span> <span class="ot">-&gt;</span> (<span class="dt">Store</span>, <span class="dt">Env</span>)</span>
<span id="cb98-38"><a href="#cb98-38"></a>procDecl sto env (<span class="dt">NewVar</span> x d) <span class="ot">=</span> </span>
<span id="cb98-39"><a href="#cb98-39"></a>  procDecl sto&#39; env&#39; d </span>
<span id="cb98-40"><a href="#cb98-40"></a>  <span class="kw">where</span> (addr, sto&#39;) <span class="ot">=</span> alloc sto  <span class="co">-- allocate a new address in the store</span></span>
<span id="cb98-41"><a href="#cb98-41"></a>        env&#39; <span class="ot">=</span> add x addr env     <span class="co">-- bind the requested name to the new address</span></span>
<span id="cb98-42"><a href="#cb98-42"></a>procDecl sto env <span class="dt">Empty</span> <span class="ot">=</span> (sto, env)</span>
<span id="cb98-43"><a href="#cb98-43"></a></span>
<span id="cb98-44"><a href="#cb98-44"></a><span class="ot">evalExpr ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb98-45"><a href="#cb98-45"></a><span class="op">...</span></span>
<span id="cb98-46"><a href="#cb98-46"></a>evalExpr env sto (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="co">-- NEW </span></span>
<span id="cb98-47"><a href="#cb98-47"></a>  <span class="kw">do</span> addr <span class="ot">&lt;-</span> get x env     <span class="co">-- first we find the address of the variable</span></span>
<span id="cb98-48"><a href="#cb98-48"></a>     get addr sto          <span class="co">-- then we find the value in the store</span></span>
<span id="cb98-49"><a href="#cb98-49"></a><span class="op">...</span></span>
<span id="cb98-50"><a href="#cb98-50"></a></span>
<span id="cb98-51"><a href="#cb98-51"></a><span class="ot">execStmt ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> (<span class="dt">Store</span>, <span class="dt">Stmt</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Store</span>, <span class="dt">Out</span>)</span>
<span id="cb98-52"><a href="#cb98-52"></a>execStmt env (sto, <span class="dt">Assign</span> x e) <span class="ot">=</span>  <span class="co">-- NEW</span></span>
<span id="cb98-53"><a href="#cb98-53"></a>  <span class="kw">case</span> evalExpr env sto e <span class="kw">of</span>      <span class="co">-- first evaluate the expression to assign</span></span>
<span id="cb98-54"><a href="#cb98-54"></a>       <span class="dt">Just</span> v <span class="ot">-&gt;</span> </span>
<span id="cb98-55"><a href="#cb98-55"></a>         <span class="kw">case</span> get x env <span class="kw">of</span>        <span class="co">-- find the address of the variable</span></span>
<span id="cb98-56"><a href="#cb98-56"></a>              <span class="dt">Just</span> addr <span class="ot">-&gt;</span> <span class="dt">Just</span> (add addr v sto, []) <span class="co">-- &quot;overwrite&quot; the address in the store</span></span>
<span id="cb98-57"><a href="#cb98-57"></a>              _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb98-58"><a href="#cb98-58"></a>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb98-59"><a href="#cb98-59"></a>execStmt env (sto, <span class="dt">Seq</span> c1 c2) <span class="ot">=</span> <span class="op">...</span> <span class="co">-- same as before</span></span>
<span id="cb98-60"><a href="#cb98-60"></a>execStmt env (sto, <span class="dt">Print</span> e) <span class="ot">=</span> <span class="op">...</span> <span class="co">-- same as before</span></span>
<span id="cb98-61"><a href="#cb98-61"></a>execStmt env (sto, <span class="dt">Block</span> d s) <span class="ot">=</span> <span class="co">-- NEW: the structure of a block is similar to let</span></span>
<span id="cb98-62"><a href="#cb98-62"></a>  <span class="kw">let</span> (sto&#39;, env&#39;) <span class="ot">=</span> procDecl sto env d <span class="co">-- process declarations (allocating variables in the store)</span></span>
<span id="cb98-63"><a href="#cb98-63"></a>  <span class="kw">in</span> execStmt env&#39; (sto&#39;, s)            <span class="co">-- execute statements in the store</span></span></code></pre></div>
<h1 id="formal-operational-semantics">Formal Operational Semantics</h1>
<h1 id="types-and-type-systems">Types and Type Systems</h1>
<!--
# Haskell Corner:

# Haskell Corner: Maybe, case of, Monads and do-notation

Since we introduced `Maybe a`, we have used many nested `case ... of`{.haskell} constructs. There is a repeating pattern:

```haskell
case eval env e1 of
  Just v1 -> case eval env e2 of
              Just v2 -> ...v1...v2...
              Nothing -> Nothing
  Nothing -> Nothing
```
-->
<!-- # Formal Semantics -->
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Later, we will add extensions that make many things simpler and also allow us to build realistic programming languages.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
